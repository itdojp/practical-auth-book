<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第3章 演習問題解答 - 実践 認証認可システム設計</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            overflow-x: hidden;
            width: 100%;
        }
        .book-layout {
            display: flex;
            min-height: 100vh;
            width: 100%;
            position: relative;
        }
        .book-sidebar {
            width: 280px;
            background-color: #fff;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
            position: fixed;
            height: 100vh;
        }
        .book-main {
            margin-left: 280px;
            flex: 1;
            padding: 40px;
            max-width: 900px;
        }
        .sidebar-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .nav-section {
            margin-bottom: 30px;
        }
        .nav-section-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }
        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .nav-link {
            display: block;
            padding: 8px 12px;
            color: #495057;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .nav-link:hover {
            background-color: #e9ecef;
            color: #007bff;
        }
        .nav-link.active {
            background-color: #007bff;
            color: white;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            color: #6c757d;
            text-align: center;
        }
        @media (max-width: 768px) {
            .book-sidebar {
                display: none;
            }
            .book-main {
                margin-left: 0;
                padding: 15px;
                max-width: 100%;
                width: 100%;
                overflow-x: hidden;
            }
            .container {
                padding: 15px;
                margin: 0;
                box-shadow: none;
                border-radius: 0;
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }
            h1 {
                font-size: 1.8rem;
                line-height: 1.3;
            }
            h2 {
                font-size: 1.4rem;
                line-height: 1.3;
                margin-top: 2rem;
            }
            h3 {
                font-size: 1.2rem;
                line-height: 1.3;
                margin-top: 1.5rem;
            }
            /* コードブロックのモバイル最適化 */
            pre {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding: 12px;
                font-size: 0.85rem;
                line-height: 1.4;
                white-space: pre;
                word-wrap: normal;
                max-width: 100%;
                margin: 1rem 0;
            }
            code {
                font-size: 0.85rem;
                word-break: break-word;
                white-space: pre-wrap;
            }
            pre code {
                white-space: pre;
                word-break: normal;
            }
            /* テーブルのモバイル対応 */
            table {
                width: 100%;
                overflow-x: auto;
                display: block;
                white-space: nowrap;
            }
            table tbody {
                display: table;
                width: 100%;
            }
            /* リストの調整 */
            ul, ol {
                padding-left: 1.2rem;
            }
            li {
                margin-bottom: 0.3rem;
            }
            /* 画像の最適化 */
            img {
                max-width: 100%;
                height: auto;
                display: block;
                margin: 1rem auto;
            }
            /* 長いURLやテキストの折り返し */
            p {
                word-wrap: break-word;
                overflow-wrap: break-word;
                max-width: 100%;
            }
            /* ボックスモデルの調整 */
            * {
                box-sizing: border-box;
            }
            /* フォントサイズの調整 */
            body {
                font-size: 0.95rem;
                line-height: 1.6;
            }
        }
    </style>
</head>
<body>
    <div class="book-layout">
        <!-- Sidebar Navigation -->
        <aside class="book-sidebar">
            <div class="sidebar-title">
                <a href="/practical-auth-book/" style="color: inherit; text-decoration: none;">実践 認証認可システム設計</a>
            </div>
            
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/introduction" class="nav-link">はじめに</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第I部: 基礎概念編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-01-overview" class="nav-link">第1章: 認証認可の全体像</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-02-authentication" class="nav-link">第2章: 認証の基礎</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-03-authorization" class="nav-link">第3章: 認可の基礎</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第II部: プロトコルと標準編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-04-session" class="nav-link">第4章: セッション管理</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-05-token-auth" class="nav-link">第5章: トークンベース認証</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-06-oauth2" class="nav-link">第6章: OAuth 2.0</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-07-oidc-saml" class="nav-link">第7章: OpenID ConnectとSAML</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第III部: 実装編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-08-auth-system-design" class="nav-link">第8章: 認証システムの設計</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-09-microservices-auth" class="nav-link">第9章: マイクロサービスでの認証認可</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-10-implementation-patterns" class="nav-link">第10章: 実装パターンとベストプラクティス</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第IV部: 応用編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-11-security-threats" class="nav-link">第11章: セキュリティ脅威と対策</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-12-performance" class="nav-link">第12章: パフォーマンス最適化</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-13-future" class="nav-link">第13章: 認証技術の未来</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">付録</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/appendices/appendix-a-libraries" class="nav-link">付録A: 主要ライブラリ・ツール一覧</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-b-troubleshooting" class="nav-link">付録B: トラブルシューティングガイド</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-c-glossary" class="nav-link">付録C: 用語集</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-d-references" class="nav-link">付録D: 参考文献・リソース</a></li>
                    </ul>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="book-main">
            <div class="container">
                </p><h1>第3章 演習問題解答</h1><h2>問題1：RBACシステムの設計</h2><h3>中規模IT企業のRBAC設計</h3><p><pre><code>python
<p>class CompanyRBACDesign:</p>
<p>    """中規模IT企業（300名）のRBAC設計"""</p>
    
<p>    def __init__(self):</p>
<p>        self.departments = self._define_departments()</p>
<p>        self.roles = self._define_roles()</p>
<p>        self.permissions = self._define_permissions()</p>
<p>        self.separation_of_duties = self._define_sod_rules()</p>
    
<p>    def _define_departments(self):</p>
<p>        """部門構造の定義"""</p>
<p>        return {</p>
<p>            'engineering': {</p>
<p>                'name': '開発部門',</p>
<p>                'size': 120,</p>
<p>                'sub_departments': ['frontend', 'backend', 'qa', 'devops']</p>
<p>            },</p>
<p>            'sales': {</p>
<p>                'name': '営業部門', </p>
<p>                'size': 80,</p>
<p>                'sub_departments': ['direct_sales', 'partner_sales', 'customer_success']</p>
<p>            },</p>
<p>            'management': {</p>
<p>                'name': '管理部門',</p>
<p>                'size': 50,</p>
<p>                'sub_departments': ['finance', 'legal', 'facilities']</p>
<p>            },</p>
<p>            'hr': {</p>
<p>                'name': '人事部門',</p>
<p>                'size': 50,</p>
<p>                'sub_departments': ['recruitment', 'training', 'compensation']</p>
<p>            }</p>
<p>        }</p>
    
<p>    def _define_roles(self):</p>
<p>        """役割の階層構造"""</p>
<p>        return {</p>
<p>            # 全社共通役割</p>
<p>            'employee': {</p>
<p>                'name': '一般社員',</p>
<p>                'parent': None,</p>
<p>                'permissions': [</p>
<p>                    'read_public_info',</p>
<p>                    'update_own_profile',</p>
<p>                    'submit_expense',</p>
<p>                    'view_org_chart'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            # 開発部門の役割</p>
<p>            'developer': {</p>
<p>                'name': '開発者',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'read_source_code',</p>
<p>                    'write_source_code',</p>
<p>                    'create_branch',</p>
<p>                    'view_ci_results'</p>
<p>                ]</p>
<p>            },</p>
<p>            'senior_developer': {</p>
<p>                'name': 'シニア開発者',</p>
<p>                'parent': 'developer',</p>
<p>                'permissions': [</p>
<p>                    'merge_to_main',</p>
<p>                    'create_release_tag',</p>
<p>                    'modify_ci_config'</p>
<p>                ]</p>
<p>            },</p>
<p>            'tech_lead': {</p>
<p>                'name': 'テックリード',</p>
<p>                'parent': 'senior_developer',</p>
<p>                'permissions': [</p>
<p>                    'approve_architecture',</p>
<p>                    'manage_team_resources',</p>
<p>                    'production_deployment'</p>
<p>                ]</p>
<p>            },</p>
<p>            'qa_engineer': {</p>
<p>                'name': 'QAエンジニア',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'read_source_code',</p>
<p>                    'create_test_cases',</p>
<p>                    'execute_tests',</p>
<p>                    'file_bugs',</p>
<p>                    'access_staging_env'</p>
<p>                ]</p>
<p>            },</p>
<p>            'devops_engineer': {</p>
<p>                'name': 'DevOpsエンジニア',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'manage_infrastructure',</p>
<p>                    'view_system_logs',</p>
<p>                    'modify_deployment_config',</p>
<p>                    'access_production_readonly'</p>
<p>                ]</p>
<p>            },</p>
<p>            'devops_lead': {</p>
<p>                'name': 'DevOpsリード',</p>
<p>                'parent': 'devops_engineer',</p>
<p>                'permissions': [</p>
<p>                    'access_production_write',</p>
<p>                    'modify_security_groups',</p>
<p>                    'manage_ssl_certificates',</p>
<p>                    'emergency_shutdown'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            # 営業部門の役割</p>
<p>            'sales_rep': {</p>
<p>                'name': '営業担当',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'read_customer_data',</p>
<p>                    'create_opportunity',</p>
<p>                    'update_opportunity',</p>
<p>                    'view_sales_reports'</p>
<p>                ]</p>
<p>            },</p>
<p>            'sales_manager': {</p>
<p>                'name': '営業マネージャー',</p>
<p>                'parent': 'sales_rep',</p>
<p>                'permissions': [</p>
<p>                    'approve_discount',</p>
<p>                    'view_team_pipeline',</p>
<p>                    'modify_territory',</p>
<p>                    'access_competitor_analysis'</p>
<p>                ]</p>
<p>            },</p>
<p>            'customer_success': {</p>
<p>                'name': 'カスタマーサクセス',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'read_customer_data',</p>
<p>                    'create_support_ticket',</p>
<p>                    'view_usage_analytics',</p>
<p>                    'schedule_customer_meeting'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            # 管理部門の役割</p>
<p>            'accountant': {</p>
<p>                'name': '経理担当',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'view_financial_reports',</p>
<p>                    'process_invoices',</p>
<p>                    'manage_ar_ap',</p>
<p>                    'run_financial_queries'</p>
<p>                ]</p>
<p>            },</p>
<p>            'finance_manager': {</p>
<p>                'name': '財務マネージャー',</p>
<p>                'parent': 'accountant',</p>
<p>                'permissions': [</p>
<p>                    'approve_payments',</p>
<p>                    'modify_budgets',</p>
<p>                    'access_bank_accounts',</p>
<p>                    'sign_contracts'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            # 人事部門の役割</p>
<p>            'hr_specialist': {</p>
<p>                'name': 'HR担当',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'read_employee_data',</p>
<p>                    'manage_benefits',</p>
<p>                    'process_leave_requests',</p>
<p>                    'view_org_metrics'</p>
<p>                ]</p>
<p>            },</p>
<p>            'hr_manager': {</p>
<p>                'name': 'HRマネージャー',</p>
<p>                'parent': 'hr_specialist',</p>
<p>                'permissions': [</p>
<p>                    'modify_employee_data',</p>
<p>                    'view_compensation_data',</p>
<p>                    'approve_promotions',</p>
<p>                    'access_performance_reviews'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            # 管理職共通</p>
<p>            'manager': {</p>
<p>                'name': 'マネージャー',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'approve_team_expense',</p>
<p>                    'view_team_performance',</p>
<p>                    'manage_team_schedule',</p>
<p>                    'conduct_reviews'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            # システム管理役割</p>
<p>            'system_admin': {</p>
<p>                'name': 'システム管理者',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'manage_user_accounts',</p>
<p>                    'reset_passwords',</p>
<p>                    'view_audit_logs',</p>
<p>                    'manage_system_config'</p>
<p>                ]</p>
<p>            },</p>
<p>            'security_admin': {</p>
<p>                'name': 'セキュリティ管理者',</p>
<p>                'parent': 'employee',</p>
<p>                'permissions': [</p>
<p>                    'manage_security_policies',</p>
<p>                    'review_access_logs',</p>
<p>                    'investigate_incidents',</p>
<p>                    'manage_certificates'</p>
<p>                ]</p>
<p>            }</p>
<p>        }</p>
    
<p>    def _define_sod_rules(self):</p>
<p>        """職務分離ルールの定義"""</p>
<p>        return [</p>
<p>            {</p>
<p>                'name': '開発と本番デプロイの分離',</p>
<p>                'conflicting_roles': ['developer', 'devops_lead'],</p>
<p>                'exception_process': 'CTO承認が必要'</p>
<p>            },</p>
<p>            {</p>
<p>                'name': '財務承認の分離',</p>
<p>                'conflicting_roles': ['accountant', 'finance_manager'],</p>
<p>                'description': '請求書作成者と承認者は別人物である必要'</p>
<p>            },</p>
<p>            {</p>
<p>                'name': 'セキュリティ監査の独立性',</p>
<p>                'conflicting_roles': ['system_admin', 'security_admin'],</p>
<p>                'description': 'システム管理者は自身の行動を監査できない'</p>
<p>            },</p>
<p>            {</p>
<p>                'name': '人事データアクセスの制限',</p>
<p>                'conflicting_permissions': [</p>
<p>                    ['view_compensation_data', 'approve_payments'],</p>
<p>                    ['modify_employee_data', 'process_invoices']</p>
<p>                ],</p>
<p>                'description': '給与情報と支払い処理の分離'</p>
<p>            }</p>
<p>        ]</p>
    
<p>    def implement_role_assignment_workflow(self):</p>
<p>        """役割割り当てワークフロー"""</p>
        
<p>        class RoleAssignmentWorkflow:</p>
<p>            def __init__(self):</p>
<p>                self.approval_matrix = {</p>
<p>                    # role: [required_approvers]</p>
<p>                    'developer': ['tech_lead', 'hr_specialist'],</p>
<p>                    'senior_developer': ['tech_lead', 'manager'],</p>
<p>                    'tech_lead': ['cto', 'hr_manager'],</p>
<p>                    'devops_engineer': ['devops_lead', 'security_admin'],</p>
<p>                    'devops_lead': ['cto', 'security_admin'],</p>
<p>                    'finance_manager': ['cfo', 'ceo'],</p>
<p>                    'system_admin': ['cto', 'security_admin'],</p>
<p>                    'security_admin': ['ciso', 'ceo']</p>
<p>                }</p>
            
<p>            def request_role(self, user_id: str, requested_role: str, </p>
<p>                           justification: str):</p>
<p>                """役割リクエストの作成"""</p>
                
<p>                request = {</p>
<p>                    'id': f'req_{int(time.time())}',</p>
<p>                    'user_id': user_id,</p>
<p>                    'requested_role': requested_role,</p>
<p>                    'justification': justification,</p>
<p>                    'status': 'pending',</p>
<p>                    'required_approvals': self.approval_matrix.get(</p>
<p>                        requested_role, ['manager']</p>
<p>                    ),</p>
<p>                    'approvals': [],</p>
<p>                    'created_at': time.time()</p>
<p>                }</p>
                
<p>                # SODチェック</p>
<p>                sod_violations = self.check_sod_violations(user_id, requested_role)</p>
<p>                if sod_violations:</p>
<p>                    request['sod_violations'] = sod_violations</p>
<p>                    request['required_approvals'].append('compliance_officer')</p>
                
<p>                return request</p>
            
<p>            def check_sod_violations(self, user_id: str, new_role: str):</p>
<p>                """職務分離違反のチェック"""</p>
<p>                current_roles = self.get_user_roles(user_id)</p>
<p>                violations = []</p>
                
<p>                for sod_rule in self.sod_rules:</p>
<p>                    if new_role in sod_rule['conflicting_roles']:</p>
<p>                        conflicts = set(current_roles) & set(sod_rule['conflicting_roles'])</p>
<p>                        if conflicts:</p>
<p>                            violations.append({</p>
<p>                                'rule': sod_rule['name'],</p>
<p>                                'conflicting_roles': list(conflicts)</p>
<p>                            })</p>
                
<p>                return violations</p>
        
<p>        return RoleAssignmentWorkflow()</p>
    
<p>    def generate_access_matrix_report(self):</p>
<p>        """アクセスマトリックスレポートの生成"""</p>
        
<p>        report = {</p>
<p>            'generated_at': datetime.now().isoformat(),</p>
<p>            'total_users': 300,</p>
<p>            'total_roles': len(self.roles),</p>
<p>            'total_permissions': len(self._get_all_permissions()),</p>
<p>            'role_distribution': {},</p>
<p>            'critical_permissions': {},</p>
<p>            'sod_compliance': []</p>
<p>        }</p>
        
<p>        # 役割分布の分析</p>
<p>        for dept, info in self.departments.items():</p>
<p>            dept_roles = self._analyze_department_roles(dept)</p>
<p>            report['role_distribution'][dept] = {</p>
<p>                'employee_count': info['size'],</p>
<p>                'roles': dept_roles,</p>
<p>                'avg_permissions_per_user': self._calculate_avg_permissions(dept)</p>
<p>            }</p>
        
<p>        # 重要権限の保持者</p>
<p>        critical_perms = [</p>
<p>            'access_production_write',</p>
<p>            'approve_payments', </p>
<p>            'modify_employee_data',</p>
<p>            'access_bank_accounts'</p>
<p>        ]</p>
        
<p>        for perm in critical_perms:</p>
<p>            holders = self._find_permission_holders(perm)</p>
<p>            report['critical_permissions'][perm] = {</p>
<p>                'holder_count': len(holders),</p>
<p>                'roles': holders,</p>
<p>                'last_review': '2024-03-01'</p>
<p>            }</p>
        
<p>        return report</p>
<p></code></pre></p><h3>実装のポイント</h3><p>1. <strong>階層的な役割設計</strong></p>
<p>   - 基本役割（employee）から継承</p>
<p>   - 部門特有の役割を定義</p>
<p>   - 権限の積み上げ方式</p><p>2. <strong>職務分離の実装</strong></p>
<p>   - 相反する役割の定義</p>
<p>   - 例外承認プロセス</p>
<p>   - 自動違反検出</p><p>3. <strong>承認ワークフロー</strong></p>
<p>   - 役割に応じた承認者</p>
<p>   - SOD違反時の追加承認</p>
<p>   - 監査証跡の保持</p><h2>問題2：ABACポリシーの作成</h2><h3>医療記録システムのABACポリシー</h3><p><pre><code>python</p>
<p>class MedicalRecordABACPolicies:</p>
<p>    """医療記録システムのABACポリシー実装"""</p>
    
<p>    def __init__(self):</p>
<p>        self.policies = []</p>
<p>        self._create_policies()</p>
    
<p>    def _create_policies(self):</p>
<p>        """ポリシーの作成"""</p>
        
<p>        # ポリシー1: 患者の自己記録アクセス</p>
<p>        self.policies.append({</p>
<p>            'id': 'patient_own_record',</p>
<p>            'description': '患者は自分の医療記録のみ閲覧可能',</p>
<p>            'priority': 10,</p>
<p>            'condition': """</p>
<p>                user['role'] == 'patient' and </p>
<p>                user['patient_id'] == resource['patient_id'] and</p>
<p>                action in ['read', 'download']</p>
<p>            """,</p>
<p>            'effect': 'ALLOW'</p>
<p>        })</p>
        
<p>        # ポリシー2: 担当医のアクセス</p>
<p>        self.policies.append({</p>
<p>            'id': 'assigned_doctor_access',</p>
<p>            'description': '担当医は担当患者の記録を閲覧・編集可能',</p>
<p>            'priority': 20,</p>
<p>            'condition': """</p>
<p>                user['role'] == 'doctor' and</p>
<p>                resource['patient_id'] in user['assigned_patients'] and</p>
<p>                action in ['read', 'write', 'update'] and</p>
<p>                not resource.get('locked', False)</p>
<p>            """,</p>
<p>            'effect': 'ALLOW'</p>
<p>        })</p>
        
<p>        # ポリシー3: 診療時間外の制限</p>
<p>        self.policies.append({</p>
<p>            'id': 'after_hours_readonly',</p>
<p>            'description': '診療時間外は読み取りのみ',</p>
<p>            'priority': 30,</p>
<p>            'condition': """</p>
<p>                user['role'] in ['doctor', 'nurse'] and</p>
<p>                not in_time_range('08:00', '18:00') and</p>
<p>                action in ['write', 'update', 'delete']</p>
<p>            """,</p>
<p>            'effect': 'DENY'</p>
<p>        })</p>
        
<p>        # ポリシー4: 緊急時アクセス</p>
<p>        self.policies.append({</p>
<p>            'id': 'emergency_access',</p>
<p>            'description': '緊急時は任意の医師が閲覧可能',</p>
<p>            'priority': 40,</p>
<p>            'condition': """</p>
<p>                user['role'] == 'doctor' and</p>
<p>                env.get('emergency_mode', False) and</p>
<p>                action == 'read' and</p>
<p>                user['license_status'] == 'active'</p>
<p>            """,</p>
<p>            'effect': 'ALLOW',</p>
<p>            'obligations': ['log_emergency_access', 'notify_patient']</p>
<p>        })</p>
        
<p>        # ポリシー5: 看護師のアクセス</p>
<p>        self.policies.append({</p>
<p>            'id': 'nurse_access',</p>
<p>            'description': '看護師は担当病棟の患者記録を閲覧可能',</p>
<p>            'priority': 25,</p>
<p>            'condition': """</p>
<p>                user['role'] == 'nurse' and</p>
<p>                resource['ward'] == user['assigned_ward'] and</p>
<p>                action == 'read' and</p>
<p>                resource['record_type'] in ['vitals', 'medication', 'nursing_notes']</p>
<p>            """,</p>
<p>            'effect': 'ALLOW'</p>
<p>        })</p>
        
<p>        # ポリシー6: 機密記録の保護</p>
<p>        self.policies.append({</p>
<p>            'id': 'sensitive_record_protection',</p>
<p>            'description': '精神科・HIV等の機密記録は特別な権限が必要',</p>
<p>            'priority': 50,</p>
<p>            'condition': """</p>
<p>                resource.get('sensitivity_level', 'normal') == 'high' and</p>
<p>                not user.get('special_access_granted', False)</p>
<p>            """,</p>
<p>            'effect': 'DENY'</p>
<p>        })</p>
        
<p>        # ポリシー7: 記録の変更履歴</p>
<p>        self.policies.append({</p>
<p>            'id': 'audit_trail_requirement',</p>
<p>            'description': 'すべての変更操作は監査ログ必須',</p>
<p>            'priority': 5,</p>
<p>            'condition': """</p>
<p>                action in ['write', 'update', 'delete']</p>
<p>            """,</p>
<p>            'effect': 'ALLOW',</p>
<p>            'obligations': ['create_audit_log', 'capture_change_reason']</p>
<p>        })</p>
        
<p>        # ポリシー8: 部門間アクセス</p>
<p>        self.policies.append({</p>
<p>            'id': 'department_access',</p>
<p>            'description': '他科の医師も必要に応じてアクセス可能',</p>
<p>            'priority': 35,</p>
<p>            'condition': """</p>
<p>                user['role'] == 'doctor' and</p>
<p>                resource['patient_id'] in user.get('consultation_requests', []) and</p>
<p>                action == 'read' and</p>
<p>                in_time_range('08:00', '20:00')</p>
<p>            """,</p>
<p>            'effect': 'ALLOW',</p>
<p>            'obligations': ['notify_primary_doctor']</p>
<p>        })</p>
    
<p>    def create_policy_engine(self):</p>
<p>        """ポリシーエンジンの実装"""</p>
        
<p>        class MedicalPolicyEngine:</p>
<p>            def __init__(self, policies):</p>
<p>                self.policies = sorted(policies, key=lambda p: p['priority'], reverse=True)</p>
<p>                self.obligation_handlers = {</p>
<p>                    'log_emergency_access': self._log_emergency_access,</p>
<p>                    'notify_patient': self._notify_patient,</p>
<p>                    'create_audit_log': self._create_audit_log,</p>
<p>                    'capture_change_reason': self._capture_change_reason,</p>
<p>                    'notify_primary_doctor': self._notify_primary_doctor</p>
<p>                }</p>
            
<p>            def evaluate(self, context):</p>
<p>                """ポリシー評価"""</p>
                
<p>                applicable_policies = []</p>
<p>                obligations = []</p>
                
<p>                for policy in self.policies:</p>
<p>                    try:</p>
<p>                        # 安全な評価環境</p>
<p>                        eval_env = {</p>
<p>                            'user': context['user'],</p>
<p>                            'resource': context['resource'],</p>
<p>                            'action': context['action'],</p>
<p>                            'env': context.get('environment', {}),</p>
<p>                            'in_time_range': self._in_time_range,</p>
<p>                            'datetime': datetime</p>
<p>                        }</p>
                        
<p>                        # 条件評価</p>
<p>                        if eval(policy['condition'], {"__builtins__": {}}, eval_env):</p>
<p>                            applicable_policies.append(policy)</p>
                            
<p>                            # DENY が優先</p>
<p>                            if policy['effect'] == 'DENY':</p>
<p>                                return {</p>
<p>                                    'decision': 'DENY',</p>
<p>                                    'reason': policy['description'],</p>
<p>                                    'applicable_policies': [policy['id']]</p>
<p>                                }</p>
                            
<p>                            # 義務の収集</p>
<p>                            if 'obligations' in policy:</p>
<p>                                obligations.extend(policy['obligations'])</p>
                    
<p>                    except Exception as e:</p>
<p>                        # ポリシーエラーは安全側に倒す（DENY）</p>
<p>                        print(f"Policy evaluation error: {policy['id']} - {e}")</p>
<p>                        continue</p>
                
<p>                # ALLOW ポリシーがあるか</p>
<p>                allow_policies = [p for p in applicable_policies if p['effect'] == 'ALLOW']</p>
                
<p>                if allow_policies:</p>
<p>                    # 義務の実行</p>
<p>                    for obligation in set(obligations):</p>
<p>                        self._execute_obligation(obligation, context)</p>
                    
<p>                    return {</p>
<p>                        'decision': 'ALLOW',</p>
<p>                        'reason': allow_policies[0]['description'],</p>
<p>                        'applicable_policies': [p['id'] for p in allow_policies],</p>
<p>                        'obligations_executed': list(set(obligations))</p>
<p>                    }</p>
                
<p>                # デフォルトは拒否</p>
<p>                return {</p>
<p>                    'decision': 'DENY',</p>
<p>                    'reason': 'No applicable ALLOW policy',</p>
<p>                    'applicable_policies': []</p>
<p>                }</p>
            
<p>            def _in_time_range(self, start: str, end: str) -> bool:</p>
<p>                """時間範囲チェック"""</p>
<p>                current = datetime.now().time()</p>
<p>                start_time = datetime.strptime(start, '%H:%M').time()</p>
<p>                end_time = datetime.strptime(end, '%H:%M').time()</p>
<p>                return start_time <= current <= end_time</p>
            
<p>            def _execute_obligation(self, obligation: str, context: dict):</p>
<p>                """義務の実行"""</p>
<p>                if obligation in self.obligation_handlers:</p>
<p>                    self.obligation_handlers<a href="context">obligation</a></p>
            
<p>            def _log_emergency_access(self, context):</p>
<p>                """緊急アクセスのログ"""</p>
<p>                log_entry = {</p>
<p>                    'timestamp': datetime.now().isoformat(),</p>
<p>                    'access_type': 'EMERGENCY',</p>
<p>                    'user': context['user']['id'],</p>
<p>                    'patient': context['resource']['patient_id'],</p>
<p>                    'reason': context.get('emergency_reason', 'Not specified'),</p>
<p>                    'action': context['action']</p>
<p>                }</p>
<p>                # 特別な監査ログに記録</p>
<p>                self._write_to_emergency_log(log_entry)</p>
            
<p>            def _notify_patient(self, context):</p>
<p>                """患者への通知"""</p>
<p>                notification = {</p>
<p>                    'patient_id': context['resource']['patient_id'],</p>
<p>                    'message': f"緊急時アクセス: Dr. {context['user']['name']}が記録を参照しました",</p>
<p>                    'timestamp': datetime.now(),</p>
<p>                    'access_details': {</p>
<p>                        'doctor': context['user']['id'],</p>
<p>                        'accessed_sections': context.get('accessed_sections', ['全般'])</p>
<p>                    }</p>
<p>                }</p>
<p>                # 通知システムに送信</p>
<p>                self._send_notification(notification)</p>
            
<p>            def _create_audit_log(self, context):</p>
<p>                """監査ログの作成"""</p>
<p>                audit_entry = {</p>
<p>                    'timestamp': datetime.now().isoformat(),</p>
<p>                    'user_id': context['user']['id'],</p>
<p>                    'user_role': context['user']['role'],</p>
<p>                    'action': context['action'],</p>
<p>                    'resource_type': 'medical_record',</p>
<p>                    'resource_id': context['resource']['id'],</p>
<p>                    'patient_id': context['resource']['patient_id'],</p>
<p>                    'ip_address': context.get('ip_address'),</p>
<p>                    'user_agent': context.get('user_agent')</p>
<p>                }</p>
<p>                # 改ざん防止のためのハッシュ</p>
<p>                audit_entry['hash'] = self._calculate_audit_hash(audit_entry)</p>
<p>                self._store_audit_log(audit_entry)</p>
        
<p>        return MedicalPolicyEngine(self.policies)</p>
<p></code></pre></p><h3>テストケース</h3><p><pre><code>python</p>
<p>def test_medical_abac_policies():</p>
<p>    """医療記録ABACポリシーのテスト"""</p>
    
<p>    engine = MedicalRecordABACPolicies().create_policy_engine()</p>
    
<p>    # テストケース1: 患者の自己記録アクセス</p>
<p>    context1 = {</p>
<p>        'user': {'role': 'patient', 'patient_id': 'P12345'},</p>
<p>        'resource': {'patient_id': 'P12345', 'type': 'medical_record'},</p>
<p>        'action': 'read'</p>
<p>    }</p>
<p>    result1 = engine.evaluate(context1)</p>
<p>    assert result1['decision'] == 'ALLOW'</p>
    
<p>    # テストケース2: 診療時間外の書き込み拒否</p>
<p>    context2 = {</p>
<p>        'user': {'role': 'doctor', 'assigned_patients': ['P12345']},</p>
<p>        'resource': {'patient_id': 'P12345'},</p>
<p>        'action': 'write',</p>
<p>        'environment': {'current_time': '21:00'}</p>
<p>    }</p>
<p>    result2 = engine.evaluate(context2)</p>
<p>    assert result2['decision'] == 'DENY'</p>
    
<p>    # テストケース3: 緊急時アクセス</p>
<p>    context3 = {</p>
<p>        'user': {'role': 'doctor', 'license_status': 'active'},</p>
<p>        'resource': {'patient_id': 'P99999'},</p>
<p>        'action': 'read',</p>
<p>        'environment': {'emergency_mode': True}</p>
<p>    }</p>
<p>    result3 = engine.evaluate(context3)</p>
<p>    assert result3['decision'] == 'ALLOW'</p>
<p>    assert 'log_emergency_access' in result3['obligations_executed']</p>
<p></code></pre></p><h2>問題3：最小権限の実装</h2><h3>既存システムへの最小権限適用計画</h3><p><pre><code>python</p>
<p>class LeastPrivilegeMigrationPlan:</p>
<p>    """最小権限原則の段階的導入計画"""</p>
    
<p>    def __init__(self):</p>
<p>        self.phases = []</p>
<p>        self.metrics = {}</p>
<p>        self.risk_mitigation = {}</p>
    
<p>    def phase1_current_state_analysis(self):</p>
<p>        """フェーズ1: 現状分析"""</p>
        
<p>        analysis_plan = {</p>
<p>            'duration': '4 weeks',</p>
<p>            'activities': {</p>
<p>                'week1': {</p>
<p>                    'name': '権限インベントリ作成',</p>
<p>                    'tasks': [</p>
<p>                        'すべてのシステム権限の洗い出し',</p>
<p>                        'ユーザー/グループの権限マッピング',</p>
<p>                        '特権アカウントの特定',</p>
<p>                        'サービスアカウントの棚卸し'</p>
<p>                    ],</p>
<p>                    'deliverable': 'permission_inventory.xlsx'</p>
<p>                },</p>
<p>                'week2': {</p>
<p>                    'name': '利用状況分析',</p>
<p>                    'tasks': [</p>
<p>                        'アクセスログの収集（90日分）',</p>
<p>                        '実際に使用された権限の特定',</p>
<p>                        '未使用権限の識別',</p>
<p>                        'アクセスパターンの分析'</p>
<p>                    ],</p>
<p>                    'deliverable': 'usage_analysis_report.pdf'</p>
<p>                },</p>
<p>                'week3': {</p>
<p>                    'name': 'リスク評価',</p>
<p>                    'tasks': [</p>
<p>                        '過剰権限によるリスクの定量化',</p>
<p>                        '権限削減による業務影響の評価',</p>
<p>                        'クリティカルな権限の特定',</p>
<p>                        'コンプライアンス要件の確認'</p>
<p>                    ],</p>
<p>                    'deliverable': 'risk_assessment_matrix.xlsx'</p>
<p>                },</p>
<p>                'week4': {</p>
<p>                    'name': '削減計画策定',</p>
<p>                    'tasks': [</p>
<p>                        '権限削減の優先順位付け',</p>
<p>                        'ユーザーグループ別の影響分析',</p>
<p>                        '段階的削減スケジュール作成',</p>
<p>                        'ロールバック計画の準備'</p>
<p>                    ],</p>
<p>                    'deliverable': 'reduction_roadmap.pdf'</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
        
<p>        # 分析ツールの実装</p>
<p>        class PermissionAnalyzer:</p>
<p>            def analyze_current_permissions(self):</p>
<p>                """現在の権限を分析"""</p>
<p>                analysis = {</p>
<p>                    'total_users': 0,</p>
<p>                    'total_permissions': 0,</p>
<p>                    'overprivileged_users': [],</p>
<p>                    'unused_permissions': [],</p>
<p>                    'high_risk_combinations': []</p>
<p>                }</p>
                
<p>                # 実装例</p>
<p>                users = self.get_all_users()</p>
<p>                for user in users:</p>
<p>                    permissions = self.get_user_permissions(user)</p>
<p>                    used_permissions = self.get_used_permissions(user, days=90)</p>
                    
<p>                    unused = set(permissions) - set(used_permissions)</p>
<p>                    if len(unused) > len(permissions) * 0.5:  # 50%以上未使用</p>
<p>                        analysis['overprivileged_users'].append({</p>
<p>                            'user': user,</p>
<p>                            'total_permissions': len(permissions),</p>
<p>                            'unused_count': len(unused),</p>
<p>                            'risk_score': self.calculate_risk_score(unused)</p>
<p>                        })</p>
                
<p>                return analysis</p>
        
<p>        return analysis_plan</p>
    
<p>    def phase2_gradual_reduction(self):</p>
<p>        """フェーズ2: 段階的な権限削減"""</p>
        
<p>        reduction_waves = [</p>
<p>            {</p>
<p>                'wave': 1,</p>
<p>                'name': '低リスク権限の削減',</p>
<p>                'duration': '2 weeks',</p>
<p>                'target': 'unused_readonly_permissions',</p>
<p>                'approach': {</p>
<p>                    'identification': '90日間未使用の読み取り専用権限',</p>
<p>                    'notification': 'ユーザーへ2週間前に通知',</p>
<p>                    'reduction': '一括削除',</p>
<p>                    'rollback': '要求に応じて48時間以内に復元'</p>
<p>                },</p>
<p>                'expected_reduction': '30%'</p>
<p>            },</p>
<p>            {</p>
<p>                'wave': 2,</p>
<p>                'name': '中リスク権限の削減',</p>
<p>                'duration': '4 weeks',</p>
<p>                'target': 'unused_write_permissions',</p>
<p>                'approach': {</p>
<p>                    'identification': '60日間未使用の書き込み権限',</p>
<p>                    'notification': 'マネージャー承認を含む通知',</p>
<p>                    'reduction': '部門単位で段階実施',</p>
<p>                    'monitoring': '削除後2週間の集中監視'</p>
<p>                },</p>
<p>                'expected_reduction': '25%'</p>
<p>            },</p>
<p>            {</p>
<p>                'wave': 3,</p>
<p>                'name': '高リスク権限の再設計',</p>
<p>                'duration': '6 weeks',</p>
<p>                'target': 'admin_and_privileged_access',</p>
<p>                'approach': {</p>
<p>                    'identification': '管理者権限の細分化',</p>
<p>                    'design': 'Just-In-Time access導入',</p>
<p>                    'implementation': 'MFA必須化と時限的権限',</p>
<p>                    'training': '新プロセスのトレーニング実施'</p>
<p>                },</p>
<p>                'expected_reduction': '40%'</p>
<p>            }</p>
<p>        ]</p>
        
<p>        # 削減実行ツール</p>
<p>        class PermissionReducer:</p>
<p>            def __init__(self):</p>
<p>                self.reduction_log = []</p>
<p>                self.rollback_queue = []</p>
            
<p>            def execute_reduction(self, wave_config):</p>
<p>                """権限削減の実行"""</p>
<p>                affected_users = self.identify_affected_users(wave_config)</p>
                
<p>                for user in affected_users:</p>
<p>                    # 削減前のスナップショット</p>
<p>                    snapshot = self.create_permission_snapshot(user)</p>
                    
<p>                    # 権限削減</p>
<p>                    removed_permissions = self.remove_permissions(</p>
<p>                        user, </p>
<p>                        wave_config['target']</p>
<p>                    )</p>
                    
<p>                    # ロールバック情報の保存</p>
<p>                    self.rollback_queue.append({</p>
<p>                        'user': user,</p>
<p>                        'snapshot': snapshot,</p>
<p>                        'removed': removed_permissions,</p>
<p>                        'timestamp': time.time(),</p>
<p>                        'expires': time.time() + (30 <em> 24 </em> 3600)  # 30日間保持</p>
<p>                    })</p>
                    
<p>                    # ログ記録</p>
<p>                    self.reduction_log.append({</p>
<p>                        'user': user,</p>
<p>                        'wave': wave_config['wave'],</p>
<p>                        'removed_count': len(removed_permissions),</p>
<p>                        'timestamp': time.time()</p>
<p>                    })</p>
            
<p>            def handle_permission_request(self, user, requested_permission):</p>
<p>                """権限リクエストの処理"""</p>
<p>                # 以前持っていた権限かチェック</p>
<p>                previous_permission = self.check_previous_permission(</p>
<p>                    user, </p>
<p>                    requested_permission</p>
<p>                )</p>
                
<p>                if previous_permission:</p>
<p>                    # 迅速な復元プロセス</p>
<p>                    return self.quick_restore(user, requested_permission)</p>
<p>                else:</p>
<p>                    # 新規権限申請プロセス</p>
<p>                    return self.new_permission_request(user, requested_permission)</p>
        
<p>        return reduction_waves</p>
    
<p>    def phase3_continuous_optimization(self):</p>
<p>        """フェーズ3: 継続的な最適化"""</p>
        
<p>        optimization_framework = {</p>
<p>            'automated_reviews': {</p>
<p>                'frequency': 'monthly',</p>
<p>                'criteria': [</p>
<p>                    'Unused permissions > 30 days',</p>
<p>                    'Anomalous access patterns',</p>
<p>                    'Role membership changes',</p>
<p>                    'Departed user cleanup'</p>
<p>                ],</p>
<p>                'actions': [</p>
<p>                    'Automatic notification',</p>
<p>                    'Manager approval required',</p>
<p>                    'Grace period: 14 days',</p>
<p>                    'Automatic removal if no response'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'just_in_time_expansion': {</p>
<p>                'implementation': [</p>
<p>                    'Break glass procedures for emergencies',</p>
<p>                    'Time-limited elevations (default: 8 hours)',</p>
<p>                    'Approval workflows based on risk',</p>
<p>                    'Automatic de-provisioning'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'metrics_and_monitoring': {</p>
<p>                'kpis': [</p>
<p>                    'Average permissions per user',</p>
<p>                    'Unused permission ratio',</p>
<p>                    'Time to provision/deprovision',</p>
<p>                    'Security incidents related to excess privileges'</p>
<p>                ],</p>
<p>                'dashboards': [</p>
<p>                    'Real-time privilege usage',</p>
<p>                    'Compliance status',</p>
<p>                    'Risk heat map',</p>
<p>                    'Trend analysis'</p>
<p>                ]</p>
<p>            }</p>
<p>        }</p>
        
<p>        return optimization_framework</p>
    
<p>    def create_communication_plan(self):</p>
<p>        """コミュニケーション計画"""</p>
        
<p>        return {</p>
<p>            'stakeholders': {</p>
<p>                'executives': {</p>
<p>                    'message': 'リスク削減とコンプライアンス向上',</p>
<p>                    'frequency': 'Monthly progress reports',</p>
<p>                    'format': 'Executive dashboard'</p>
<p>                },</p>
<p>                'managers': {</p>
<p>                    'message': 'チーム影響と承認プロセス',</p>
<p>                    'frequency': 'Bi-weekly updates',</p>
<p>                    'format': 'Department meetings'</p>
<p>                },</p>
<p>                'end_users': {</p>
<p>                    'message': '変更内容と利用可能なサポート',</p>
<p>                    'frequency': 'As needed + 2 weeks notice',</p>
<p>                    'format': 'Email + Portal notifications'</p>
<p>                },</p>
<p>                'it_team': {</p>
<p>                    'message': '技術的実装とサポート手順',</p>
<p>                    'frequency': 'Weekly sync',</p>
<p>                    'format': 'Technical documentation + Training'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'channels': [</p>
<p>                'Email campaigns',</p>
<p>                'Intranet announcements',</p>
<p>                'Team meetings',</p>
<p>                'Help desk notices',</p>
<p>                'Training sessions'</p>
<p>            ],</p>
            
<p>            'feedback_mechanism': {</p>
<p>                'collection': [</p>
<p>                    'Dedicated email address',</p>
<p>                    'Feedback form',</p>
<p>                    'Office hours',</p>
<p>                    'Anonymous suggestions'</p>
<p>                ],</p>
<p>                'response_sla': '48 hours',</p>
<p>                'escalation_path': 'Manager -> IT Security -> CISO'</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h2>問題4：認可パフォーマンスの最適化</h2><h3>高性能認可システムの設計</h3><p><pre><code>python</p>
<p>import asyncio</p>
<p>from typing import Dict, Set, Optional, Tuple</p>
<p>import hashlib</p>
<p>import pickle</p>
<p>from collections import OrderedDict</p>
<p>import aioredis</p><p>class HighPerformanceAuthorizationSystem:</p>
<p>    """1000 req/s, 10ms以下のレスポンスタイムを実現する認可システム"""</p>
    
<p>    def __init__(self):</p>
<p>        self.static_cache = StaticPermissionCache()</p>
<p>        self.dynamic_evaluator = DynamicPolicyEvaluator()</p>
<p>        self.request_router = AuthorizationRouter()</p>
<p>        self.monitoring = PerformanceMonitor()</p>
    
<p>    async def initialize(self):</p>
<p>        """システムの初期化"""</p>
<p>        # Redis接続プール</p>
<p>        self.redis_pool = await aioredis.create_redis_pool(</p>
<p>            'redis://localhost',</p>
<p>            minsize=10,</p>
<p>            maxsize=50</p>
<p>        )</p>
        
<p>        # 静的権限のプリロード</p>
<p>        await self.static_cache.preload_permissions()</p>
        
<p>        # ウォームアップ</p>
<p>        await self._warmup_caches()</p>
    
<p>    class StaticPermissionCache:</p>
<p>        """静的権限の高速キャッシュ"""</p>
        
<p>        def __init__(self):</p>
<p>            # 多層キャッシュ構造</p>
<p>            self.l1_cache = {}  # プロセスメモリ（最速）</p>
<p>            self.l2_cache = None  # Redis（共有）</p>
<p>            self.bloom_filters = {}  # 否定的キャッシュ</p>
            
<p>        async def check_permission(self, user_id: str, permission: str) -> Optional[bool]:</p>
<p>            """静的権限チェック（目標: <1ms）"""</p>
            
<p>            # L1キャッシュ（~0.01ms）</p>
<p>            cache_key = f"{user_id}:{permission}"</p>
<p>            if cache_key in self.l1_cache:</p>
<p>                self.metrics.l1_hits += 1</p>
<p>                return self.l1_cache[cache_key]</p>
            
<p>            # Bloom filterで明らかなNOを高速判定（~0.05ms）</p>
<p>            if not self._bloom_filter_check(user_id, permission):</p>
<p>                self.metrics.bloom_filter_hits += 1</p>
<p>                return False</p>
            
<p>            # L2キャッシュ（~1ms）</p>
<p>            result = await self._check_l2_cache(cache_key)</p>
<p>            if result is not None:</p>
<p>                self.metrics.l2_hits += 1</p>
<p>                self._update_l1_cache(cache_key, result)</p>
<p>                return result</p>
            
<p>            # キャッシュミス</p>
<p>            return None</p>
        
<p>        def _bloom_filter_check(self, user_id: str, permission: str) -> bool:</p>
<p>            """Bloom filterによる事前フィルタリング"""</p>
<p>            if user_id not in self.bloom_filters:</p>
<p>                return True  # フィルタがない場合は通す</p>
            
<p>            bf = self.bloom_filters[user_id]</p>
<p>            return bf.might_contain(permission)</p>
        
<p>        async def preload_permissions(self):</p>
<p>            """権限の事前ロード"""</p>
<p>            # バッチでユーザー権限を取得</p>
<p>            batch_size = 1000</p>
            
<p>            for user_batch in self._get_user_batches(batch_size):</p>
<p>                permissions_map = await self._load_user_permissions_batch(user_batch)</p>
                
<p>                for user_id, permissions in permissions_map.items():</p>
<p>                    # Bloom filter作成</p>
<p>                    bf = BloomFilter(capacity=len(permissions) * 2, error_rate=0.01)</p>
<p>                    for perm in permissions:</p>
<p>                        bf.add(perm)</p>
<p>                        # L1キャッシュに追加</p>
<p>                        self.l1_cache[f"{user_id}:{perm}"] = True</p>
                    
<p>                    self.bloom_filters[user_id] = bf</p>
    
<p>    class DynamicPolicyEvaluator:</p>
<p>        """動的ポリシー評価器"""</p>
        
<p>        def __init__(self):</p>
<p>            self.policy_cache = LRUCache(maxsize=10000)</p>
<p>            self.compiled_policies = {}</p>
<p>            self.context_cache = TTLCache(maxsize=5000, ttl=300)  # 5分</p>
            
<p>        async def evaluate(self, request: Dict) -> Tuple[bool, str]:</p>
<p>            """動的ポリシー評価（目標: <10ms for 20% of requests）"""</p>
            
<p>            # キャッシュキー生成</p>
<p>            cache_key = self._generate_cache_key(request)</p>
            
<p>            # キャッシュチェック（~0.1ms）</p>
<p>            cached = self.policy_cache.get(cache_key)</p>
<p>            if cached and not self._is_expired(cached):</p>
<p>                return cached['result'], cached['reason']</p>
            
<p>            # コンテキスト収集（並列化）</p>
<p>            context = await self._gather_context_parallel(request)</p>
            
<p>            # ポリシー評価（最適化済み）</p>
<p>            result, reason = await self._evaluate_policies_optimized(context)</p>
            
<p>            # 結果をキャッシュ</p>
<p>            self.policy_cache[cache_key] = {</p>
<p>                'result': result,</p>
<p>                'reason': reason,</p>
<p>                'timestamp': time.time(),</p>
<p>                'ttl': self._determine_cache_ttl(context)</p>
<p>            }</p>
            
<p>            return result, reason</p>
        
<p>        async def _gather_context_parallel(self, request: Dict) -> Dict:</p>
<p>            """並列コンテキスト収集"""</p>
            
<p>            # 必要なコンテキストを並列で取得</p>
<p>            tasks = [</p>
<p>                self._get_user_attributes(request['user_id']),</p>
<p>                self._get_resource_attributes(request['resource_id']),</p>
<p>                self._get_environment_context(),</p>
<p>                self._get_risk_score(request)</p>
<p>            ]</p>
            
<p>            results = await asyncio.gather(*tasks, return_exceptions=True)</p>
            
<p>            return {</p>
<p>                'user': results[0] if not isinstance(results[0], Exception) else {},</p>
<p>                'resource': results[1] if not isinstance(results[1], Exception) else {},</p>
<p>                'environment': results[2] if not isinstance(results[2], Exception) else {},</p>
<p>                'risk': results[3] if not isinstance(results[3], Exception) else {'score': 0}</p>
<p>            }</p>
        
<p>        async def _evaluate_policies_optimized(self, context: Dict) -> Tuple[bool, str]:</p>
<p>            """最適化されたポリシー評価"""</p>
            
<p>            # ポリシーを優先度でソート済み</p>
<p>            for policy in self.compiled_policies.values():</p>
<p>                try:</p>
<p>                    # JITコンパイルされた条件を評価</p>
<p>                    if policy<a href="context">'compiled_condition'</a>:</p>
<p>                        if policy['effect'] == 'DENY':</p>
<p>                            return False, policy['reason']</p>
<p>                        elif policy['effect'] == 'ALLOW':</p>
<p>                            return True, policy['reason']</p>
<p>                except Exception as e:</p>
<p>                    # エラーは安全側に倒す</p>
<p>                    self.logger.error(f"Policy evaluation error: {e}")</p>
<p>                    continue</p>
            
<p>            return False, "No matching policy"</p>
    
<p>    class AuthorizationRouter:</p>
<p>        """リクエストルーティングと負荷分散"""</p>
        
<p>        def __init__(self):</p>
<p>            self.static_threshold = 0.8  # 80%は静的で処理</p>
<p>            self.circuit_breaker = CircuitBreaker()</p>
            
<p>        async def route_request(self, request: Dict) -> Tuple[bool, str, Dict]:</p>
<p>            """リクエストのルーティング"""</p>
            
<p>            start_time = time.time()</p>
<p>            metrics = {'path': None, 'latency': 0}</p>
            
<p>            # 静的チェックで解決可能か判定</p>
<p>            if self._is_static_checkable(request):</p>
<p>                # 静的パス（高速）</p>
<p>                result = await self.static_cache.check_permission(</p>
<p>                    request['user_id'],</p>
<p>                    request['permission']</p>
<p>                )</p>
                
<p>                if result is not None:</p>
<p>                    metrics['path'] = 'static'</p>
<p>                    metrics['latency'] = (time.time() - start_time) * 1000</p>
<p>                    return result, "Static permission", metrics</p>
            
<p>            # 動的評価が必要</p>
<p>            if self.circuit_breaker.is_open():</p>
<p>                # サーキットブレーカーが開いている場合は失敗</p>
<p>                return False, "System overloaded", {'path': 'circuit_breaker'}</p>
            
<p>            try:</p>
<p>                result, reason = await asyncio.wait_for(</p>
<p>                    self.dynamic_evaluator.evaluate(request),</p>
<p>                    timeout=0.01  # 10msタイムアウト</p>
<p>                )</p>
                
<p>                metrics['path'] = 'dynamic'</p>
<p>                metrics['latency'] = (time.time() - start_time) * 1000</p>
                
<p>                return result, reason, metrics</p>
                
<p>            except asyncio.TimeoutError:</p>
<p>                self.circuit_breaker.record_failure()</p>
<p>                return False, "Evaluation timeout", {'path': 'timeout'}</p>
    
<p>    def create_benchmarking_suite(self):</p>
<p>        """ベンチマーキングスイート"""</p>
        
<p>        class AuthorizationBenchmark:</p>
<p>            def __init__(self, system):</p>
<p>                self.system = system</p>
<p>                self.results = {}</p>
            
<p>            async def run_benchmark(self):</p>
<p>                """包括的なベンチマークを実行"""</p>
                
<p>                print("Starting authorization system benchmark...")</p>
                
<p>                # ウォームアップ</p>
<p>                await self._warmup(1000)</p>
                
<p>                # テストシナリオ</p>
<p>                scenarios = [</p>
<p>                    {</p>
<p>                        'name': 'Static Only',</p>
<p>                        'static_ratio': 1.0,</p>
<p>                        'target_rps': 1000,</p>
<p>                        'duration': 60</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'name': 'Mixed Load (80/20)',</p>
<p>                        'static_ratio': 0.8,</p>
<p>                        'target_rps': 1000,</p>
<p>                        'duration': 60</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'name': 'Heavy Dynamic',</p>
<p>                        'static_ratio': 0.5,</p>
<p>                        'target_rps': 1000,</p>
<p>                        'duration': 60</p>
<p>                    }</p>
<p>                ]</p>
                
<p>                for scenario in scenarios:</p>
<p>                    result = await self._run_scenario(scenario)</p>
<p>                    self.results[scenario['name']] = result</p>
<p>                    self._print_results(scenario['name'], result)</p>
            
<p>            async def _run_scenario(self, scenario):</p>
<p>                """シナリオの実行"""</p>
                
<p>                start_time = time.time()</p>
<p>                request_count = 0</p>
<p>                latencies = []</p>
<p>                errors = 0</p>
                
<p>                # 並行リクエスト生成</p>
<p>                tasks = []</p>
<p>                for _ in range(scenario['target_rps']):</p>
<p>                    task = asyncio.create_task(</p>
<p>                        self._send_request(scenario['static_ratio'])</p>
<p>                    )</p>
<p>                    tasks.append(task)</p>
                    
<p>                    # レート制御</p>
<p>                    await asyncio.sleep(1.0 / scenario['target_rps'])</p>
                    
<p>                    if time.time() - start_time > scenario['duration']:</p>
<p>                        break</p>
                
<p>                # 結果収集</p>
<p>                results = await asyncio.gather(*tasks, return_exceptions=True)</p>
                
<p>                for result in results:</p>
<p>                    if isinstance(result, Exception):</p>
<p>                        errors += 1</p>
<p>                    else:</p>
<p>                        latencies.append(result['latency'])</p>
<p>                        request_count += 1</p>
                
<p>                return {</p>
<p>                    'request_count': request_count,</p>
<p>                    'errors': errors,</p>
<p>                    'avg_latency': np.mean(latencies),</p>
<p>                    'p50_latency': np.percentile(latencies, 50),</p>
<p>                    'p95_latency': np.percentile(latencies, 95),</p>
<p>                    'p99_latency': np.percentile(latencies, 99),</p>
<p>                    'throughput': request_count / scenario['duration']</p>
<p>                }</p>
        
<p>        return AuthorizationBenchmark(self)</p>
<p></code></pre></p><h3>最適化テクニックまとめ</h3><p>1. <strong>多層キャッシング</strong></p>
<p>   - L1: プロセスメモリ（<0.01ms）</p>
<p>   - L2: Redis（<1ms）</p>
<p>   - Bloom Filter: 否定的キャッシュ</p><p>2. <strong>並列処理</strong></p>
<p>   - コンテキスト収集の並列化</p>
<p>   - 非同期I/O活用</p><p>3. <strong>回路ブレーカー</strong></p>
<p>   - 過負荷時の高速失敗</p>
<p>   - システム保護</p><p>4. <strong>JITコンパイル</strong></p>
<p>   - ポリシー条件の事前コンパイル</p>
<p>   - 評価の高速化</p><h2>問題5：認可モデルの移行</h2><h3>ACLからRBACへの移行計画</h3><p><pre><code>python</p>
<p>class ACLToRBACMigration:</p>
<p>    """ACLベースシステムからRBACへの安全な移行"""</p>
    
<p>    def __init__(self):</p>
<p>        self.migration_phases = []</p>
<p>        self.rollback_points = []</p>
<p>        self.validation_rules = []</p>
    
<p>    def phase1_analysis_and_role_extraction(self):</p>
<p>        """フェーズ1: ACL分析と役割抽出"""</p>
        
<p>        class ACLAnalyzer:</p>
<p>            def __init__(self):</p>
<p>                self.acl_patterns = {}</p>
<p>                self.suggested_roles = []</p>
                
<p>            def analyze_acl_patterns(self, acl_data):</p>
<p>                """ACLパターンの分析"""</p>
                
<p>                # ユーザーグループの類似性分析</p>
<p>                user_permission_matrix = self._build_permission_matrix(acl_data)</p>
                
<p>                # クラスタリングによる役割候補の抽出</p>
<p>                from sklearn.cluster import DBSCAN</p>
                
<p>                clustering = DBSCAN(eps=0.3, min_samples=5)</p>
<p>                clusters = clustering.fit_predict(user_permission_matrix)</p>
                
<p>                # 各クラスターを役割候補として分析</p>
<p>                for cluster_id in set(clusters):</p>
<p>                    if cluster_id == -1:  # ノイズ</p>
<p>                        continue</p>
                    
<p>                    cluster_users = [</p>
<p>                        user for user, cluster in zip(users, clusters) </p>
<p>                        if cluster == cluster_id</p>
<p>                    ]</p>
                    
<p>                    # 共通権限の抽出</p>
<p>                    common_permissions = self._extract_common_permissions(</p>
<p>                        cluster_users, </p>
<p>                        threshold=0.8  # 80%以上が持つ権限</p>
<p>                    )</p>
                    
<p>                    suggested_role = {</p>
<p>                        'name': f'role_cluster_{cluster_id}',</p>
<p>                        'permissions': common_permissions,</p>
<p>                        'users': cluster_users,</p>
<p>                        'confidence': self._calculate_confidence(cluster_users, common_permissions)</p>
<p>                    }</p>
                    
<p>                    self.suggested_roles.append(suggested_role)</p>
                
<p>                return self.suggested_roles</p>
            
<p>            def generate_role_mapping_report(self):</p>
<p>                """役割マッピングレポートの生成"""</p>
                
<p>                report = {</p>
<p>                    'analysis_date': datetime.now(),</p>
<p>                    'total_users': len(self.all_users),</p>
<p>                    'total_permissions': len(self.all_permissions),</p>
<p>                    'suggested_roles': []</p>
<p>                }</p>
                
<p>                for role in self.suggested_roles:</p>
<p>                    role_analysis = {</p>
<p>                        'suggested_name': role['name'],</p>
<p>                        'permission_count': len(role['permissions']),</p>
<p>                        'user_count': len(role['users']),</p>
<p>                        'coverage': len(role['users']) / len(self.all_users),</p>
<p>                        'permission_reduction': 1 - (len(role['permissions']) / </p>
<p>                                                   self._avg_user_permissions()),</p>
<p>                        'sample_users': role['users'][:5],</p>
<p>                        'key_permissions': role['permissions'][:10]</p>
<p>                    }</p>
                    
<p>                    report['suggested_roles'].append(role_analysis)</p>
                
<p>                return report</p>
        
<p>        return ACLAnalyzer()</p>
    
<p>    def phase2_role_design_and_validation(self):</p>
<p>        """フェーズ2: 役割設計と検証"""</p>
        
<p>        validation_framework = {</p>
<p>            'coverage_test': {</p>
<p>                'description': '既存の全権限がRBACでカバーされるか',</p>
<p>                'implementation': self._validate_permission_coverage,</p>
<p>                'threshold': 1.0  # 100%カバレッジ必須</p>
<p>            },</p>
            
<p>            'granularity_test': {</p>
<p>                'description': '役割が適切な粒度か',</p>
<p>                'implementation': self._validate_role_granularity,</p>
<p>                'criteria': {</p>
<p>                    'min_users_per_role': 5,</p>
<p>                    'max_permissions_per_role': 50,</p>
<p>                    'max_role_overlap': 0.3</p>
<p>                }</p>
<p>            },</p>
            
<p>            'security_test': {</p>
<p>                'description': 'セキュリティが低下していないか',</p>
<p>                'implementation': self._validate_security_posture,</p>
<p>                'checks': [</p>
<p>                    'No privilege escalation',</p>
<p>                    'Maintains separation of duties',</p>
<p>                    'No unauthorized access expansion'</p>
<p>                ]</p>
<p>            }</p>
<p>        }</p>
        
<p>        def _validate_permission_coverage(self, old_acl, new_rbac):</p>
<p>            """権限カバレッジの検証"""</p>
            
<p>            uncovered_permissions = []</p>
            
<p>            for user in old_acl.users:</p>
<p>                old_permissions = set(old_acl.get_user_permissions(user))</p>
<p>                new_permissions = set(new_rbac.get_user_permissions(user))</p>
                
<p>                missing = old_permissions - new_permissions</p>
<p>                extra = new_permissions - old_permissions</p>
                
<p>                if missing:</p>
<p>                    uncovered_permissions.append({</p>
<p>                        'user': user,</p>
<p>                        'missing': list(missing),</p>
<p>                        'severity': self._assess_permission_criticality(missing)</p>
<p>                    })</p>
                
<p>                if extra:</p>
<p>                    # 追加権限は要注意</p>
<p>                    self.warnings.append({</p>
<p>                        'user': user,</p>
<p>                        'extra_permissions': list(extra),</p>
<p>                        'risk': 'Potential over-provisioning'</p>
<p>                    })</p>
            
<p>            return len(uncovered_permissions) == 0, uncovered_permissions</p>
        
<p>        return validation_framework</p>
    
<p>    def phase3_parallel_implementation(self):</p>
<p>        """フェーズ3: 並行実装"""</p>
        
<p>        class ParallelAuthSystem:</p>
<p>            """ACLとRBACを並行実行する認可システム"""</p>
            
<p>            def __init__(self, acl_system, rbac_system):</p>
<p>                self.acl = acl_system</p>
<p>                self.rbac = rbac_system</p>
<p>                self.mode = 'shadow'  # shadow, dual, rbac_primary, rbac_only</p>
<p>                self.discrepancy_log = []</p>
                
<p>            async def check_authorization(self, request):</p>
<p>                """並行認可チェック"""</p>
                
<p>                if self.mode == 'shadow':</p>
<p>                    # ACLが主、RBACは影で実行</p>
<p>                    acl_result = await self.acl.check(request)</p>
<p>                    rbac_result = await self.rbac.check(request)</p>
                    
<p>                    if acl_result != rbac_result:</p>
<p>                        self._log_discrepancy(request, acl_result, rbac_result)</p>
                    
<p>                    return acl_result</p>
                
<p>                elif self.mode == 'dual':</p>
<p>                    # 両方実行して安全な方を選択</p>
<p>                    acl_result = await self.acl.check(request)</p>
<p>                    rbac_result = await self.rbac.check(request)</p>
                    
<p>                    if acl_result != rbac_result:</p>
<p>                        self._log_discrepancy(request, acl_result, rbac_result)</p>
<p>                        # 移行期間中は許可的に（どちらかがOKならOK）</p>
<p>                        return acl_result or rbac_result</p>
                    
<p>                    return acl_result</p>
                
<p>                elif self.mode == 'rbac_primary':</p>
<p>                    # RBACが主、ACLは監査のみ</p>
<p>                    rbac_result = await self.rbac.check(request)</p>
                    
<p>                    # 非同期で差分チェック</p>
<p>                    asyncio.create_task(self._audit_check(request, rbac_result))</p>
                    
<p>                    return rbac_result</p>
                
<p>                else:  # rbac_only</p>
<p>                    return await self.rbac.check(request)</p>
            
<p>            def analyze_discrepancies(self):</p>
<p>                """差異分析レポート"""</p>
                
<p>                analysis = {</p>
<p>                    'total_requests': len(self.all_requests),</p>
<p>                    'discrepancy_count': len(self.discrepancy_log),</p>
<p>                    'discrepancy_rate': len(self.discrepancy_log) / len(self.all_requests),</p>
<p>                    'patterns': {}</p>
<p>                }</p>
                
<p>                # パターン分析</p>
<p>                for disc in self.discrepancy_log:</p>
<p>                    pattern = self._identify_pattern(disc)</p>
<p>                    if pattern not in analysis['patterns']:</p>
<p>                        analysis['patterns'][pattern] = {</p>
<p>                            'count': 0,</p>
<p>                            'examples': []</p>
<p>                        }</p>
                    
<p>                    analysis['patterns'][pattern]['count'] += 1</p>
<p>                    if len(analysis['patterns'][pattern]['examples']) < 5:</p>
<p>                        analysis['patterns'][pattern]['examples'].append(disc)</p>
                
<p>                return analysis</p>
        
<p>        return ParallelAuthSystem</p>
    
<p>    def phase4_cutover_and_validation(self):</p>
<p>        """フェーズ4: 切り替えと検証"""</p>
        
<p>        cutover_plan = {</p>
<p>            'pre_cutover_checklist': [</p>
<p>                {</p>
<p>                    'item': 'Discrepancy rate < 0.1%',</p>
<p>                    'verification': 'analyze_last_7_days_logs()',</p>
<p>                    'required': True</p>
<p>                },</p>
<p>                {</p>
<p>                    'item': 'Performance metrics stable',</p>
<p>                    'verification': 'check_latency_p99() < baseline * 1.1',</p>
<p>                    'required': True</p>
<p>                },</p>
<p>                {</p>
<p>                    'item': 'All critical users migrated',</p>
<p>                    'verification': 'verify_vip_users_rbac_ready()',</p>
<p>                    'required': True</p>
<p>                },</p>
<p>                {</p>
<p>                    'item': 'Rollback procedure tested',</p>
<p>                    'verification': 'rollback_test_successful()',</p>
<p>                    'required': True</p>
<p>                }</p>
<p>            ],</p>
            
<p>            'cutover_sequence': [</p>
<p>                {</p>
<p>                    'step': 1,</p>
<p>                    'action': 'Enable RBAC primary mode',</p>
<p>                    'rollback': 'Switch back to dual mode',</p>
<p>                    'validation': 'Monitor error rate for 1 hour',</p>
<p>                    'success_criteria': 'Error rate < 0.01%'</p>
<p>                },</p>
<p>                {</p>
<p>                    'step': 2,</p>
<p>                    'action': 'Disable ACL writes',</p>
<p>                    'rollback': 'Re-enable ACL writes',</p>
<p>                    'validation': 'Verify all permission changes via RBAC',</p>
<p>                    'success_criteria': 'No failed permission updates'</p>
<p>                },</p>
<p>                {</p>
<p>                    'step': 3,</p>
<p>                    'action': 'Switch to RBAC only mode',</p>
<p>                    'rollback': 'Re-enable parallel mode',</p>
<p>                    'validation': 'Full system test',</p>
<p>                    'success_criteria': 'All integration tests pass'</p>
<p>                },</p>
<p>                {</p>
<p>                    'step': 4,</p>
<p>                    'action': 'Decommission ACL system',</p>
<p>                    'rollback': 'Keep ACL data for 90 days',</p>
<p>                    'validation': 'Final audit comparison',</p>
<p>                    'success_criteria': 'No access issues reported'</p>
<p>                }</p>
<p>            ],</p>
            
<p>            'post_cutover_monitoring': {</p>
<p>                'duration': '30 days',</p>
<p>                'metrics': [</p>
<p>                    'Authorization latency',</p>
<p>                    'Permission denied rate',</p>
<p>                    'User complaints',</p>
<p>                    'System errors'</p>
<p>                ],</p>
<p>                'alerts': {</p>
<p>                    'latency_spike': 'p99 > baseline * 1.5',</p>
<p>                    'error_spike': 'error_rate > 0.1%',</p>
<p>                    'user_complaints': 'tickets > normal * 2'</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
        
<p>        return cutover_plan</p>
<p></code></pre></p><h2>チャレンジ問題：Zero Trust認可の設計</h2><h3>Zero Trustアーキテクチャに基づく認可システム</h3><p><pre><code>python</p>
<p>class ZeroTrustAuthorizationSystem:</p>
<p>    """Zero Trust原則に基づく次世代認可システム"""</p>
    
<p>    def __init__(self):</p>
<p>        self.trust_engine = ContinuousTrustEngine()</p>
<p>        self.policy_engine = DynamicPolicyEngine()</p>
<p>        self.micro_segmentation = MicroSegmentationController()</p>
<p>        self.audit_system = ComprehensiveAuditSystem()</p>
    
<p>    class ContinuousTrustEngine:</p>
<p>        """継続的な信頼性評価エンジン"""</p>
        
<p>        def __init__(self):</p>
<p>            self.trust_factors = {</p>
<p>                'device_health': 0.2,</p>
<p>                'user_behavior': 0.3,</p>
<p>                'network_security': 0.2,</p>
<p>                'authentication_strength': 0.2,</p>
<p>                'time_and_location': 0.1</p>
<p>            }</p>
<p>            self.ml_model = self._load_anomaly_detection_model()</p>
        
<p>        async def calculate_trust_score(self, context):</p>
<p>            """リアルタイムの信頼スコア計算"""</p>
            
<p>            scores = {}</p>
            
<p>            # デバイスヘルス</p>
<p>            scores['device_health'] = await self._assess_device_health(</p>
<p>                context['device_id']</p>
<p>            )</p>
            
<p>            # ユーザー行動分析</p>
<p>            scores['user_behavior'] = await self._analyze_user_behavior(</p>
<p>                context['user_id'],</p>
<p>                context['recent_actions']</p>
<p>            )</p>
            
<p>            # ネットワークセキュリティ</p>
<p>            scores['network_security'] = await self._evaluate_network_security(</p>
<p>                context['source_ip'],</p>
<p>                context['network_path']</p>
<p>            )</p>
            
<p>            # 認証強度</p>
<p>            scores['authentication_strength'] = self._calculate_auth_strength(</p>
<p>                context['auth_methods'],</p>
<p>                context['session_age']</p>
<p>            )</p>
            
<p>            # 時間と場所</p>
<p>            scores['time_and_location'] = self._assess_spatiotemporal_risk(</p>
<p>                context['timestamp'],</p>
<p>                context['geolocation']</p>
<p>            )</p>
            
<p>            # 重み付き平均</p>
<p>            trust_score = sum(</p>
<p>                scores[factor] * weight </p>
<p>                for factor, weight in self.trust_factors.items()</p>
<p>            )</p>
            
<p>            # 異常検知</p>
<p>            anomaly_score = self.ml_model.predict_anomaly(context)</p>
            
<p>            # 最終スコア（異常があれば大幅減点）</p>
<p>            final_score = trust_score * (1 - anomaly_score)</p>
            
<p>            return {</p>
<p>                'trust_score': final_score,</p>
<p>                'factors': scores,</p>
<p>                'anomaly_detected': anomaly_score > 0.7,</p>
<p>                'timestamp': time.time()</p>
<p>            }</p>
        
<p>        async def _assess_device_health(self, device_id):</p>
<p>            """デバイスの健全性評価"""</p>
            
<p>            checks = {</p>
<p>                'os_updated': await self._check_os_version(device_id),</p>
<p>                'antivirus_active': await self._check_antivirus(device_id),</p>
<p>                'firewall_enabled': await self._check_firewall(device_id),</p>
<p>                'disk_encrypted': await self._check_encryption(device_id),</p>
<p>                'patches_current': await self._check_patches(device_id),</p>
<p>                'no_malware': await self._scan_for_threats(device_id)</p>
<p>            }</p>
            
<p>            # コンプライアンススコア計算</p>
<p>            compliance_score = sum(checks.values()) / len(checks)</p>
            
<p>            # デバイスの信頼性履歴</p>
<p>            history_score = await self._get_device_trust_history(device_id)</p>
            
<p>            return compliance_score <em> 0.7 + history_score </em> 0.3</p>
    
<p>    class DynamicPolicyEngine:</p>
<p>        """動的ポリシーエンジン"""</p>
        
<p>        def __init__(self):</p>
<p>            self.policies = self._load_zero_trust_policies()</p>
<p>            self.context_enrichers = []</p>
            
<p>        def create_zero_trust_policies(self):</p>
<p>            """Zero Trust ポリシーの定義"""</p>
            
<p>            policies = [</p>
<p>                {</p>
<p>                    'id': 'continuous_verification',</p>
<p>                    'name': '継続的検証の要求',</p>
<p>                    'condition': """</p>
<p>                    # 信頼スコアが閾値を下回ったら再認証</p>
<p>                    if context['trust_score'] < 0.6:</p>
<p>                        require_reauthentication()</p>
                    
<p>                    # 高リスク操作には追加検証</p>
<p>                    if context['action_risk_level'] == 'high' and context['trust_score'] < 0.8:</p>
<p>                        require_mfa()</p>
<p>                    """,</p>
<p>                    'effect': 'CONDITIONAL_ALLOW'</p>
<p>                },</p>
                
<p>                {</p>
<p>                    'id': 'least_privilege_enforcement',</p>
<p>                    'name': '最小権限の動的適用',</p>
<p>                    'condition': """</p>
<p>                    # 信頼レベルに応じて権限を制限</p>
<p>                    allowed_permissions = calculate_allowed_permissions(</p>
<p>                        base_permissions=user['role_permissions'],</p>
<p>                        trust_score=context['trust_score'],</p>
<p>                        resource_sensitivity=resource['classification']</p>
<p>                    )</p>
                    
<p>                    return requested_permission in allowed_permissions</p>
<p>                    """,</p>
<p>                    'effect': 'DYNAMIC_ALLOW'</p>
<p>                },</p>
                
<p>                {</p>
<p>                    'id': 'micro_segmentation',</p>
<p>                    'name': 'マイクロセグメンテーション',</p>
<p>                    'condition': """</p>
<p>                    # ネットワークセグメント間のアクセス制御</p>
<p>                    source_segment = get_network_segment(context['source_ip'])</p>
<p>                    target_segment = get_network_segment(resource['location'])</p>
                    
<p>                    if not is_allowed_segment_access(source_segment, target_segment):</p>
<p>                        return False</p>
                    
<p>                    # East-West トラフィックの検査</p>
<p>                    return inspect_lateral_movement(context)</p>
<p>                    """,</p>
<p>                    'effect': 'ALLOW'</p>
<p>                },</p>
                
<p>                {</p>
<p>                    'id': 'data_centric_security',</p>
<p>                    'name': 'データ中心のセキュリティ',</p>
<p>                    'condition': """</p>
<p>                    # データの分類に基づくアクセス制御</p>
<p>                    data_classification = resource['data_classification']</p>
<p>                    user_clearance = user['clearance_level']</p>
                    
<p>                    if not has_clearance(user_clearance, data_classification):</p>
<p>                        return False</p>
                    
<p>                    # データの利用目的チェック</p>
<p>                    if not validate_purpose(context['stated_purpose'], resource['allowed_purposes']):</p>
<p>                        return False</p>
                    
<p>                    # データの移動制限</p>
<p>                    if is_data_export(context['action']) and not user['export_authorized']:</p>
<p>                        return False</p>
                    
<p>                    return True</p>
<p>                    """,</p>
<p>                    'effect': 'ALLOW'</p>
<p>                }</p>
<p>            ]</p>
            
<p>            return policies</p>
    
<p>    class MicroSegmentationController:</p>
<p>        """マイクロセグメンテーション制御"""</p>
        
<p>        def __init__(self):</p>
<p>            self.segments = {}</p>
<p>            self.policies = {}</p>
<p>            self.sdn_controller = SDNController()</p>
        
<p>        def define_segments(self):</p>
<p>            """セグメントの定義"""</p>
            
<p>            segments = {</p>
<p>                'user_workstations': {</p>
<p>                    'cidr': '10.1.0.0/16',</p>
<p>                    'trust_level': 'low',</p>
<p>                    'allowed_services': ['web', 'email'],</p>
<p>                    'inspection_level': 'full'</p>
<p>                },</p>
                
<p>                'application_tier': {</p>
<p>                    'cidr': '10.2.0.0/16',</p>
<p>                    'trust_level': 'medium',</p>
<p>                    'allowed_services': ['api', 'database_client'],</p>
<p>                    'inspection_level': 'moderate'</p>
<p>                },</p>
                
<p>                'database_tier': {</p>
<p>                    'cidr': '10.3.0.0/16',</p>
<p>                    'trust_level': 'high',</p>
<p>                    'allowed_services': ['database'],</p>
<p>                    'inspection_level': 'minimal',</p>
<p>                    'access_requirements': ['mfa', 'privileged_account']</p>
<p>                },</p>
                
<p>                'dmz': {</p>
<p>                    'cidr': '10.4.0.0/16',</p>
<p>                    'trust_level': 'untrusted',</p>
<p>                    'allowed_services': ['public_web'],</p>
<p>                    'inspection_level': 'paranoid'</p>
<p>                }</p>
<p>            }</p>
            
<p>            return segments</p>
        
<p>        async def enforce_segmentation(self, source, destination, context):</p>
<p>            """セグメンテーションの実施"""</p>
            
<p>            source_segment = self._identify_segment(source)</p>
<p>            dest_segment = self._identify_segment(destination)</p>
            
<p>            # セグメント間ポリシーチェック</p>
<p>            policy = self._get_segment_policy(source_segment, dest_segment)</p>
            
<p>            if not policy:</p>
<p>                # デフォルト拒否</p>
<p>                return {</p>
<p>                    'allowed': False,</p>
<p>                    'reason': 'No policy defined for segment pair'</p>
<p>                }</p>
            
<p>            # 追加の検証</p>
<p>            validations = []</p>
            
<p>            # 時間ベースアクセス</p>
<p>            if 'time_restrictions' in policy:</p>
<p>                validations.append(</p>
<p>                    self._check_time_restrictions(policy['time_restrictions'])</p>
<p>                )</p>
            
<p>            # プロトコル検査</p>
<p>            if 'allowed_protocols' in policy:</p>
<p>                validations.append(</p>
<p>                    context['protocol'] in policy['allowed_protocols']</p>
<p>                )</p>
            
<p>            # ペイロード検査</p>
<p>            if policy.get('deep_packet_inspection', False):</p>
<p>                validations.append(</p>
<p>                    await self._inspect_payload(context['payload'])</p>
<p>                )</p>
            
<p>            # すべての検証に合格した場合のみ許可</p>
<p>            return {</p>
<p>                'allowed': all(validations),</p>
<p>                'applied_policy': policy['id'],</p>
<p>                'validations': validations</p>
<p>            }</p>
    
<p>    class ComprehensiveAuditSystem:</p>
<p>        """包括的な監査システム"""</p>
        
<p>        def __init__(self):</p>
<p>            self.audit_pipeline = self._create_audit_pipeline()</p>
<p>            self.compliance_frameworks = ['SOC2', 'ISO27001', 'NIST']</p>
            
<p>        def _create_audit_pipeline(self):</p>
<p>            """監査パイプラインの構築"""</p>
            
<p>            return {</p>
<p>                'collection': {</p>
<p>                    'sources': [</p>
<p>                        'authorization_decisions',</p>
<p>                        'trust_score_changes',</p>
<p>                        'policy_evaluations',</p>
<p>                        'network_flows',</p>
<p>                        'data_access_logs'</p>
<p>                    ],</p>
<p>                    'enrichment': [</p>
<p>                        'user_context',</p>
<p>                        'asset_information',</p>
<p>                        'threat_intelligence'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'processing': {</p>
<p>                    'real_time_analysis': [</p>
<p>                        'anomaly_detection',</p>
<p>                        'threat_correlation',</p>
<p>                        'compliance_violations'</p>
<p>                    ],</p>
<p>                    'storage': {</p>
<p>                        'hot_storage': '7_days',</p>
<p>                        'warm_storage': '90_days',</p>
<p>                        'cold_storage': '7_years'</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'reporting': {</p>
<p>                    'dashboards': [</p>
<p>                        'executive_overview',</p>
<p>                        'security_operations',</p>
<p>                        'compliance_status'</p>
<p>                    ],</p>
<p>                    'alerts': {</p>
<p>                        'high_priority': ['unauthorized_access', 'data_exfiltration'],</p>
<p>                        'medium_priority': ['policy_violations', 'trust_degradation'],</p>
<p>                        'low_priority': ['configuration_drift', 'maintenance_required']</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
        
<p>        async def generate_compliance_report(self, framework='SOC2'):</p>
<p>            """コンプライアンスレポートの生成"""</p>
            
<p>            report = {</p>
<p>                'framework': framework,</p>
<p>                'period': 'last_quarter',</p>
<p>                'executive_summary': {},</p>
<p>                'detailed_findings': {},</p>
<p>                'recommendations': []</p>
<p>            }</p>
            
<p>            # 各コントロールの評価</p>
<p>            controls = self._get_framework_controls(framework)</p>
            
<p>            for control in controls:</p>
<p>                evaluation = await self._evaluate_control(control)</p>
                
<p>                report['detailed_findings'][control['id']] = {</p>
<p>                    'description': control['description'],</p>
<p>                    'status': evaluation['status'],</p>
<p>                    'evidence': evaluation['evidence'],</p>
<p>                    'gaps': evaluation['gaps'],</p>
<p>                    'remediation': evaluation['remediation']</p>
<p>                }</p>
            
<p>            # サマリー生成</p>
<p>            report['executive_summary'] = {</p>
<p>                'overall_compliance': self._calculate_compliance_score(report),</p>
<p>                'critical_findings': self._extract_critical_findings(report),</p>
<p>                'improvement_areas': self._identify_improvements(report)</p>
<p>            }</p>
            
<p>            return report</p>
    
<p>    def implement_zero_trust_flow(self):</p>
<p>        """Zero Trust フローの実装"""</p>
        
<p>        async def authorize_request(self, request):</p>
<p>            """Zero Trust 認可フロー"""</p>
            
<p>            # ステップ1: 継続的な信頼性評価</p>
<p>            trust_result = await self.trust_engine.calculate_trust_score(request)</p>
            
<p>            if trust_result['trust_score'] < 0.3:</p>
<p>                # 信頼スコアが低すぎる場合は即座に拒否</p>
<p>                await self.audit_system.log_high_risk_denial(request, trust_result)</p>
<p>                return {</p>
<p>                    'decision': 'DENY',</p>
<p>                    'reason': 'Insufficient trust score',</p>
<p>                    'required_action': 'reauthenticate'</p>
<p>                }</p>
            
<p>            # ステップ2: コンテキストの強化</p>
<p>            enriched_context = await self._enrich_context(request, trust_result)</p>
            
<p>            # ステップ3: 動的ポリシー評価</p>
<p>            policy_result = await self.policy_engine.evaluate(enriched_context)</p>
            
<p>            # ステップ4: マイクロセグメンテーションチェック</p>
<p>            if policy_result['decision'] == 'ALLOW':</p>
<p>                segment_result = await self.micro_segmentation.enforce_segmentation(</p>
<p>                    request['source'],</p>
<p>                    request['destination'],</p>
<p>                    enriched_context</p>
<p>                )</p>
                
<p>                if not segment_result['allowed']:</p>
<p>                    policy_result['decision'] = 'DENY'</p>
<p>                    policy_result['reason'] = segment_result['reason']</p>
            
<p>            # ステップ5: 条件付き許可の処理</p>
<p>            if policy_result['decision'] == 'CONDITIONAL_ALLOW':</p>
<p>                conditions_met = await self._verify_conditions(</p>
<p>                    policy_result['conditions'],</p>
<p>                    enriched_context</p>
<p>                )</p>
                
<p>                if not conditions_met:</p>
<p>                    policy_result['decision'] = 'DENY'</p>
<p>                    policy_result['reason'] = 'Conditions not met'</p>
            
<p>            # ステップ6: 包括的な監査</p>
<p>            await self.audit_system.log_authorization_decision(</p>
<p>                request,</p>
<p>                trust_result,</p>
<p>                policy_result,</p>
<p>                enriched_context</p>
<p>            )</p>
            
<p>            # ステップ7: 継続的なモニタリングの設定</p>
<p>            if policy_result['decision'] == 'ALLOW':</p>
<p>                await self._setup_continuous_monitoring(</p>
<p>                    request['session_id'],</p>
<p>                    trust_result['trust_score']</p>
<p>                )</p>
            
<p>            return policy_result</p>
<p></code></pre></p><h3>Zero Trust実装のまとめ</h3><p>1. <strong>継続的検証</strong></p>
<p>   - リアルタイムの信頼性評価</p>
<p>   - 動的な権限調整</p>
<p>   - セッション中の再認証</p><p>2. <strong>最小権限の徹底</strong></p>
<p>   - Just-In-Time アクセス</p>
<p>   - 条件付き権限付与</p>
<p>   - 自動権限失効</p><p>3. <strong>マイクロセグメンテーション</strong></p>
<p>   - ネットワークレベルの分離</p>
<p>   - East-Westトラフィックの検査</p>
<p>   - セグメント間ポリシー</p><p>4. <strong>包括的な可視性</strong></p>
<p>   - 全アクセスの記録</p>
<p>   - リアルタイム分析</p>
<p>   - コンプライアンス自動化</p>
            </div>
        </main>
    </div>
</body>
</html>