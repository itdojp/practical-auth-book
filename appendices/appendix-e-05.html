<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第5章 演習問題解答 - 実践 認証認可システム設計</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }
        .book-layout {
            display: flex;
            min-height: 100vh;
        }
        .book-sidebar {
            width: 280px;
            background-color: #fff;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
            position: fixed;
            height: 100vh;
        }
        .book-main {
            margin-left: 280px;
            flex: 1;
            padding: 40px;
            max-width: 900px;
        }
        .sidebar-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .nav-section {
            margin-bottom: 30px;
        }
        .nav-section-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }
        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .nav-link {
            display: block;
            padding: 8px 12px;
            color: #495057;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .nav-link:hover {
            background-color: #e9ecef;
            color: #007bff;
        }
        .nav-link.active {
            background-color: #007bff;
            color: white;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            color: #6c757d;
            text-align: center;
        }
        @media (max-width: 768px) {
            .book-sidebar {
                display: none;
            }
            .book-main {
                margin-left: 0;
                padding: 15px;
                max-width: 100%;
            }
            .container {
                padding: 20px;
                margin: 0;
                box-shadow: none;
                border-radius: 0;
            }
            h1 {
                font-size: 1.8rem;
                line-height: 1.3;
            }
            h2 {
                font-size: 1.4rem;
                line-height: 1.3;
                margin-top: 2rem;
            }
            h3 {
                font-size: 1.2rem;
                line-height: 1.3;
                margin-top: 1.5rem;
            }
            /* コードブロックのモバイル最適化 */
            pre {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding: 12px;
                font-size: 0.85rem;
                line-height: 1.4;
                white-space: pre;
                word-wrap: normal;
            }
            code {
                font-size: 0.85rem;
                word-break: break-word;
                white-space: pre-wrap;
            }
            pre code {
                white-space: pre;
                word-break: normal;
            }
            /* テーブルのモバイル対応 */
            table {
                width: 100%;
                overflow-x: auto;
                display: block;
                white-space: nowrap;
            }
            table tbody {
                display: table;
                width: 100%;
            }
            /* リストの調整 */
            ul, ol {
                padding-left: 1.2rem;
            }
            li {
                margin-bottom: 0.3rem;
            }
            /* 画像の最適化 */
            img {
                max-width: 100%;
                height: auto;
                display: block;
                margin: 1rem auto;
            }
            /* 長いURLやテキストの折り返し */
            p {
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
            /* フォントサイズの調整 */
            body {
                font-size: 0.95rem;
                line-height: 1.6;
            }
        }
    </style>
</head>
<body>
    <div class="book-layout">
        <!-- Sidebar Navigation -->
        <aside class="book-sidebar">
            <div class="sidebar-title">
                <a href="/practical-auth-book/" style="color: inherit; text-decoration: none;">実践 認証認可システム設計</a>
            </div>
            
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/introduction" class="nav-link">はじめに</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第I部: 基礎概念編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-01-overview" class="nav-link">第1章: 認証認可の全体像</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-02-authentication" class="nav-link">第2章: 認証の基礎</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-03-authorization" class="nav-link">第3章: 認可の基礎</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第II部: プロトコルと標準編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-04-session" class="nav-link">第4章: セッション管理</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-05-token-auth" class="nav-link">第5章: トークンベース認証</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-06-oauth2" class="nav-link">第6章: OAuth 2.0</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-07-oidc-saml" class="nav-link">第7章: OpenID ConnectとSAML</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第III部: 実装編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-08-auth-system-design" class="nav-link">第8章: 認証システムの設計</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-09-microservices-auth" class="nav-link">第9章: マイクロサービスでの認証認可</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-10-implementation-patterns" class="nav-link">第10章: 実装パターンとベストプラクティス</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第IV部: 応用編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-11-security-threats" class="nav-link">第11章: セキュリティ脅威と対策</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-12-performance" class="nav-link">第12章: パフォーマンス最適化</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-13-future" class="nav-link">第13章: 認証技術の未来</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">付録</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/appendices/appendix-a-libraries" class="nav-link">付録A: 主要ライブラリ・ツール一覧</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-b-troubleshooting" class="nav-link">付録B: トラブルシューティングガイド</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-c-glossary" class="nav-link">付録C: 用語集</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-d-references" class="nav-link">付録D: 参考文献・リソース</a></li>
                    </ul>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="book-main">
            <div class="container">
                </p><h1>第5章 演習問題解答</h1><h2>問題1：JWT実装</h2><h3>解答</h3><p><pre><code>python
<p>import jwt</p>
<p>import time</p>
<p>import uuid</p>
<p>from cryptography.hazmat.primitives import serialization</p>
<p>from cryptography.hazmat.primitives.asymmetric import rsa</p>
<p>from cryptography.hazmat.backends import default_backend</p>
<p>from typing import Dict, Tuple, Optional</p>
<p>import redis</p><p>class JWTAuthSystem:</p>
<p>    """RS256を使用したJWT認証システム"""</p>
    
<p>    def __init__(self):</p>
<p>        # RSA鍵ペアの生成</p>
<p>        self.private_key = rsa.generate_private_key(</p>
<p>            public_exponent=65537,</p>
<p>            key_size=2048,</p>
<p>            backend=default_backend()</p>
<p>        )</p>
<p>        self.public_key = self.private_key.public_key()</p>
        
<p>        # Redis接続（トークン管理用）</p>
<p>        self.redis = redis.Redis(decode_responses=True)</p>
        
<p>        # 設定</p>
<p>        self.ACCESS_TOKEN_LIFETIME = 900  # 15分</p>
<p>        self.REFRESH_TOKEN_LIFETIME = 604800  # 7日</p>
        
<p>    def generate_token_pair(self, user_id: str) -> Dict[str, str]:</p>
<p>        """アクセストークンとリフレッシュトークンのペアを生成"""</p>
        
<p>        # 共通のトークンファミリーID</p>
<p>        family_id = str(uuid.uuid4())</p>
        
<p>        # アクセストークンの生成</p>
<p>        access_payload = {</p>
<p>            'user_id': user_id,</p>
<p>            'type': 'access',</p>
<p>            'family_id': family_id,</p>
<p>            'jti': str(uuid.uuid4()),</p>
<p>            'iat': int(time.time()),</p>
<p>            'exp': int(time.time() + self.ACCESS_TOKEN_LIFETIME)</p>
<p>        }</p>
        
<p>        access_token = self._encode_token(access_payload)</p>
        
<p>        # リフレッシュトークンの生成</p>
<p>        refresh_payload = {</p>
<p>            'user_id': user_id,</p>
<p>            'type': 'refresh',</p>
<p>            'family_id': family_id,</p>
<p>            'jti': str(uuid.uuid4()),</p>
<p>            'iat': int(time.time()),</p>
<p>            'exp': int(time.time() + self.REFRESH_TOKEN_LIFETIME),</p>
<p>            'rotation_count': 0</p>
<p>        }</p>
        
<p>        refresh_token = self._encode_token(refresh_payload)</p>
        
<p>        # リフレッシュトークンをRedisに保存</p>
<p>        self._store_refresh_token(refresh_payload)</p>
        
<p>        return {</p>
<p>            'access_token': access_token,</p>
<p>            'refresh_token': refresh_token,</p>
<p>            'token_type': 'Bearer',</p>
<p>            'expires_in': self.ACCESS_TOKEN_LIFETIME</p>
<p>        }</p>
    
<p>    def refresh_tokens(self, refresh_token: str) -> Optional[Dict[str, str]]:</p>
<p>        """トークンローテーションを実装したリフレッシュ処理"""</p>
        
<p>        try:</p>
<p>            # リフレッシュトークンの検証</p>
<p>            payload = self._decode_token(refresh_token)</p>
            
<p>            # トークンタイプの確認</p>
<p>            if payload.get('type') != 'refresh':</p>
<p>                raise ValueError("Invalid token type")</p>
            
<p>            # Redisでトークンの状態確認</p>
<p>            stored_token = self._get_stored_token(payload['jti'])</p>
<p>            if not stored_token:</p>
<p>                # トークンが既に使用済みまたは無効</p>
<p>                self._handle_token_reuse_detection(payload)</p>
<p>                return None</p>
            
<p>            # 新しいトークンペアの生成</p>
<p>            new_tokens = self.generate_token_pair(payload['user_id'])</p>
            
<p>            # 新しいリフレッシュトークンにローテーション回数を引き継ぐ</p>
<p>            new_refresh_payload = self._decode_token(new_tokens['refresh_token'])</p>
<p>            new_refresh_payload['rotation_count'] = payload.get('rotation_count', 0) + 1</p>
<p>            new_refresh_payload['family_id'] = payload['family_id']</p>
            
<p>            # 古いリフレッシュトークンを無効化</p>
<p>            self._revoke_token(payload['jti'])</p>
            
<p>            return new_tokens</p>
            
<p>        except jwt.ExpiredSignatureError:</p>
<p>            return None</p>
<p>        except Exception as e:</p>
<p>            print(f"Token refresh error: {e}")</p>
<p>            return None</p>
    
<p>    def _encode_token(self, payload: Dict) -> str:</p>
<p>        """RS256でトークンをエンコード"""</p>
<p>        private_pem = self.private_key.private_bytes(</p>
<p>            encoding=serialization.Encoding.PEM,</p>
<p>            format=serialization.PrivateFormat.PKCS8,</p>
<p>            encryption_algorithm=serialization.NoEncryption()</p>
<p>        )</p>
        
<p>        return jwt.encode(payload, private_pem, algorithm='RS256')</p>
    
<p>    def _decode_token(self, token: str) -> Dict:</p>
<p>        """RS256でトークンをデコード"""</p>
<p>        public_pem = self.public_key.public_bytes(</p>
<p>            encoding=serialization.Encoding.PEM,</p>
<p>            format=serialization.PublicFormat.SubjectPublicKeyInfo</p>
<p>        )</p>
        
<p>        return jwt.decode(token, public_pem, algorithms=['RS256'])</p>
    
<p>    def _store_refresh_token(self, payload: Dict):</p>
<p>        """リフレッシュトークンをRedisに保存"""</p>
<p>        key = f"refresh_token:{payload['jti']}"</p>
<p>        ttl = payload['exp'] - int(time.time())</p>
        
<p>        self.redis.setex(</p>
<p>            key,</p>
<p>            ttl,</p>
<p>            json.dumps({</p>
<p>                'user_id': payload['user_id'],</p>
<p>                'family_id': payload['family_id'],</p>
<p>                'rotation_count': payload.get('rotation_count', 0)</p>
<p>            })</p>
<p>        )</p>
    
<p>    def _get_stored_token(self, jti: str) -> Optional[Dict]:</p>
<p>        """保存されたトークン情報を取得"""</p>
<p>        data = self.redis.get(f"refresh_token:{jti}")</p>
<p>        return json.loads(data) if data else None</p>
    
<p>    def _revoke_token(self, jti: str):</p>
<p>        """トークンを無効化"""</p>
<p>        self.redis.delete(f"refresh_token:{jti}")</p>
    
<p>    def _handle_token_reuse_detection(self, payload: Dict):</p>
<p>        """トークン再利用検出時の処理"""</p>
<p>        # 同じファミリーのすべてのトークンを無効化</p>
<p>        pattern = f"refresh_token:*"</p>
<p>        for key in self.redis.scan_iter(match=pattern):</p>
<p>            token_data = json.loads(self.redis.get(key))</p>
<p>            if token_data.get('family_id') == payload['family_id']:</p>
<p>                self.redis.delete(key)</p>
        
<p>        # セキュリティアラートをログ</p>
<p>        print(f"SECURITY ALERT: Token reuse detected for user {payload['user_id']}")</p>
    
<p>    def verify_access_token(self, token: str) -> Optional[Dict]:</p>
<p>        """アクセストークンの検証"""</p>
<p>        try:</p>
<p>            payload = self._decode_token(token)</p>
            
<p>            if payload.get('type') != 'access':</p>
<p>                return None</p>
                
<p>            return payload</p>
            
<p>        except jwt.ExpiredSignatureError:</p>
<p>            return None</p>
<p>        except Exception:</p>
<p>            return None</p><h1>エラーハンドリングを含む使用例</h1>
<p>def main():</p>
<p>    auth_system = JWTAuthSystem()</p>
    
<p>    try:</p>
<p>        # 初回ログイン</p>
<p>        tokens = auth_system.generate_token_pair("user123")</p>
<p>        print(f"Initial tokens generated")</p>
        
<p>        # アクセストークンの検証</p>
<p>        user_info = auth_system.verify_access_token(tokens['access_token'])</p>
<p>        if user_info:</p>
<p>            print(f"Access token valid for user: {user_info['user_id']}")</p>
        
<p>        # トークンのリフレッシュ</p>
<p>        new_tokens = auth_system.refresh_tokens(tokens['refresh_token'])</p>
<p>        if new_tokens:</p>
<p>            print("Tokens refreshed successfully")</p>
<p>        else:</p>
<p>            print("Token refresh failed")</p>
            
<p>    except Exception as e:</p>
<p>        print(f"Authentication error: {e}")</p>
<p></code></pre></p><h3>実装のポイント</h3><p>1. <strong>RS256アルゴリズム</strong>：公開鍵暗号を使用し、検証者が署名を作成できない</p>
<p>2. <strong>トークンローテーション</strong>：リフレッシュトークンは一度使用すると無効化</p>
<p>3. <strong>ファミリーベースの無効化</strong>：再利用検出時に関連トークンすべてを無効化</p>
<p>4. <strong>適切なエラーハンドリング</strong>：各種例外を適切に処理</p><h2>問題2：トークン保存戦略</h2><h3>解答</h3><p><pre><code>javascript</p>
<p>// SPAアプリケーション向けトークン保存戦略</p>
<p>class SecureTokenStorage {</p>
<p>    constructor() {</p>
<p>        // メモリ内でアクセストークンを保持</p>
<p>        this.accessToken = null;</p>
<p>        this.tokenExpiry = null;</p>
        
<p>        // リフレッシュ処理の状態管理</p>
<p>        this.refreshPromise = null;</p>
        
<p>        // CSRFトークン</p>
<p>        this.csrfToken = this.generateCSRFToken();</p>
<p>    }</p>
    
<p>    // トークン保存戦略の実装</p>
<p>    async initialize() {</p>
<p>        // 1. CSRFトークンをメタタグから取得</p>
<p>        const metaTag = document.querySelector('meta[name="csrf-token"]');</p>
<p>        if (metaTag) {</p>
<p>            this.csrfToken = metaTag.content;</p>
<p>        }</p>
        
<p>        // 2. 初回のトークン取得（リフレッシュトークンはHttpOnly Cookieに保存済み）</p>
<p>        await this.refreshAccessToken();</p>
        
<p>        // 3. 自動リフレッシュの設定</p>
<p>        this.setupAutoRefresh();</p>
        
<p>        // 4. XSS対策の追加レイヤー</p>
<p>        this.setupSecurityHeaders();</p>
<p>    }</p>
    
<p>    // アクセストークンの取得（メモリのみ）</p>
<p>    async getAccessToken() {</p>
<p>        // 有効期限チェック</p>
<p>        if (!this.accessToken || this.isTokenExpiring()) {</p>
<p>            await this.refreshAccessToken();</p>
<p>        }</p>
        
<p>        return this.accessToken;</p>
<p>    }</p>
    
<p>    // トークンのリフレッシュ</p>
<p>    async refreshAccessToken() {</p>
<p>        // 重複リフレッシュを防ぐ</p>
<p>        if (this.refreshPromise) {</p>
<p>            return this.refreshPromise;</p>
<p>        }</p>
        
<p>        this.refreshPromise = fetch('/api/auth/refresh', {</p>
<p>            method: 'POST',</p>
<p>            credentials: 'include', // HttpOnly Cookieを含める</p>
<p>            headers: {</p>
<p>                'Content-Type': 'application/json',</p>
<p>                'X-CSRF-Token': this.csrfToken // CSRF対策</p>
<p>            }</p>
<p>        })</p>
<p>        .then(response => {</p>
<p>            if (!response.ok) {</p>
<p>                throw new Error('Token refresh failed');</p>
<p>            }</p>
<p>            return response.json();</p>
<p>        })</p>
<p>        .then(data => {</p>
<p>            // メモリにのみ保存</p>
<p>            this.accessToken = data.access_token;</p>
<p>            this.tokenExpiry = Date.now() + (data.expires_in * 1000);</p>
            
<p>            // CSRFトークンが更新された場合</p>
<p>            if (data.csrf_token) {</p>
<p>                this.csrfToken = data.csrf_token;</p>
<p>            }</p>
            
<p>            this.refreshPromise = null;</p>
<p>            return this.accessToken;</p>
<p>        })</p>
<p>        .catch(error => {</p>
<p>            this.refreshPromise = null;</p>
<p>            this.handleAuthError(error);</p>
<p>            throw error;</p>
<p>        });</p>
        
<p>        return this.refreshPromise;</p>
<p>    }</p>
    
<p>    // APIリクエストラッパー（XSS/CSRF対策込み）</p>
<p>    async secureApiRequest(url, options = {}) {</p>
<p>        const token = await this.getAccessToken();</p>
        
<p>        // デフォルトヘッダーの設定</p>
<p>        const headers = {</p>
<p>            ...options.headers,</p>
<p>            'Authorization': <code>Bearer ${token}</code>,</p>
<p>            'X-CSRF-Token': this.csrfToken,</p>
<p>            'X-Content-Type-Options': 'nosniff',</p>
<p>            'X-Frame-Options': 'DENY'</p>
<p>        };</p>
        
<p>        // Content-Type の検証</p>
<p>        if (options.body && typeof options.body === 'object') {</p>
<p>            headers['Content-Type'] = 'application/json';</p>
<p>            options.body = JSON.stringify(options.body);</p>
<p>        }</p>
        
<p>        try {</p>
<p>            const response = await fetch(url, {</p>
<p>                ...options,</p>
<p>                headers,</p>
<p>                credentials: 'include'</p>
<p>            });</p>
            
<p>            // レスポンスヘッダーの検証</p>
<p>            this.validateResponseHeaders(response);</p>
            
<p>            // 401の場合は自動リトライ</p>
<p>            if (response.status === 401 && !options._retry) {</p>
<p>                await this.refreshAccessToken();</p>
<p>                return this.secureApiRequest(url, { ...options, _retry: true });</p>
<p>            }</p>
            
<p>            return response;</p>
            
<p>        } catch (error) {</p>
<p>            console.error('API request failed:', error);</p>
<p>            throw error;</p>
<p>        }</p>
<p>    }</p>
    
<p>    // XSS対策：Content Security Policy の動的設定</p>
<p>    setupSecurityHeaders() {</p>
<p>        // メタタグでCSPを設定</p>
<p>        const cspMeta = document.createElement('meta');</p>
<p>        cspMeta.httpEquiv = 'Content-Security-Policy';</p>
<p>        cspMeta.content = [</p>
<p>            "default-src 'self'",</p>
<p>            "script-src 'self' 'nonce-" + this.generateNonce() + "'",</p>
<p>            "style-src 'self' 'unsafe-inline'",</p>
<p>            "img-src 'self' data: https:",</p>
<p>            "connect-src 'self'",</p>
<p>            "frame-ancestors 'none'",</p>
<p>            "form-action 'self'"</p>
<p>        ].join('; ');</p>
<p>        document.head.appendChild(cspMeta);</p>
<p>    }</p>
    
<p>    // トークン有効期限のチェック</p>
<p>    isTokenExpiring() {</p>
<p>        if (!this.tokenExpiry) return true;</p>
        
<p>        // 5分前にリフレッシュ</p>
<p>        const bufferTime = 5 <em> 60 </em> 1000;</p>
<p>        return Date.now() >= (this.tokenExpiry - bufferTime);</p>
<p>    }</p>
    
<p>    // 自動リフレッシュの設定</p>
<p>    setupAutoRefresh() {</p>
<p>        // 可視性変更時のリフレッシュ</p>
<p>        document.addEventListener('visibilitychange', () => {</p>
<p>            if (!document.hidden && this.isTokenExpiring()) {</p>
<p>                this.refreshAccessToken();</p>
<p>            }</p>
<p>        });</p>
        
<p>        // 定期的なチェック（1分ごと）</p>
<p>        setInterval(() => {</p>
<p>            if (this.isTokenExpiring()) {</p>
<p>                this.refreshAccessToken();</p>
<p>            }</p>
<p>        }, 60000);</p>
<p>    }</p>
    
<p>    // レスポンスヘッダーの検証</p>
<p>    validateResponseHeaders(response) {</p>
<p>        const contentType = response.headers.get('content-type');</p>
        
<p>        // JSONレスポンスの検証</p>
<p>        if (contentType && contentType.includes('application/json')) {</p>
<p>            // XSS対策：JSONレスポンスの検証</p>
<p>            const xContentType = response.headers.get('x-content-type-options');</p>
<p>            if (xContentType !== 'nosniff') {</p>
<p>                console.warn('Missing X-Content-Type-Options header');</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
    
<p>    // CSRFトークンの生成</p>
<p>    generateCSRFToken() {</p>
<p>        const array = new Uint8Array(32);</p>
<p>        crypto.getRandomValues(array);</p>
<p>        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');</p>
<p>    }</p>
    
<p>    // ナンスの生成（CSP用）</p>
<p>    generateNonce() {</p>
<p>        const array = new Uint8Array(16);</p>
<p>        crypto.getRandomValues(array);</p>
<p>        return btoa(String.fromCharCode(...array));</p>
<p>    }</p>
    
<p>    // 認証エラーの処理</p>
<p>    handleAuthError(error) {</p>
<p>        // トークンをクリア</p>
<p>        this.accessToken = null;</p>
<p>        this.tokenExpiry = null;</p>
        
<p>        // ユーザーに通知</p>
<p>        this.showAuthErrorNotification();</p>
        
<p>        // ログイン画面へリダイレクト</p>
<p>        setTimeout(() => {</p>
<p>            window.location.href = '/login';</p>
<p>        }, 2000);</p>
<p>    }</p>
    
<p>    // エラー通知の表示（XSS対策済み）</p>
<p>    showAuthErrorNotification() {</p>
<p>        const notification = document.createElement('div');</p>
<p>        notification.className = 'auth-error-notification';</p>
<p>        notification.textContent = 'セッションの有効期限が切れました。再度ログインしてください。';</p>
        
<p>        // スタイルの安全な適用</p>
<p>        notification.style.cssText = <code></p>
<p>            position: fixed;</p>
<p>            top: 20px;</p>
<p>            right: 20px;</p>
<p>            background: #f44336;</p>
<p>            color: white;</p>
<p>            padding: 16px;</p>
<p>            border-radius: 4px;</p>
<p>            z-index: 1000;</p>
<p>        </code>;</p>
        
<p>        document.body.appendChild(notification);</p>
        
<p>        // 自動削除</p>
<p>        setTimeout(() => {</p>
<p>            notification.remove();</p>
<p>        }, 5000);</p>
<p>    }</p>
    
<p>    // ログアウト処理</p>
<p>    async logout() {</p>
<p>        try {</p>
<p>            await fetch('/api/auth/logout', {</p>
<p>                method: 'POST',</p>
<p>                credentials: 'include',</p>
<p>                headers: {</p>
<p>                    'X-CSRF-Token': this.csrfToken</p>
<p>                }</p>
<p>            });</p>
<p>        } finally {</p>
<p>            // トークンをクリア</p>
<p>            this.accessToken = null;</p>
<p>            this.tokenExpiry = null;</p>
            
<p>            // ログイン画面へ</p>
<p>            window.location.href = '/login';</p>
<p>        }</p>
<p>    }</p>
<p>}</p><p>// 使用例</p>
<p>const tokenStorage = new SecureTokenStorage();</p><p>// アプリケーション初期化時</p>
<p>document.addEventListener('DOMContentLoaded', async () => {</p>
<p>    try {</p>
<p>        await tokenStorage.initialize();</p>
        
<p>        // APIリクエストの例</p>
<p>        const response = await tokenStorage.secureApiRequest('/api/user/profile');</p>
<p>        const userData = await response.json();</p>
        
<p>    } catch (error) {</p>
<p>        console.error('Initialization failed:', error);</p>
<p>    }</p>
<p>});</p>
<p></code></pre></p><h3>実装の詳細</h3><p>1. <strong>XSS対策</strong></p>
<p>   - アクセストークンはメモリのみに保持</p>
<p>   - Content Security Policy（CSP）の実装</p>
<p>   - レスポンスヘッダーの検証</p>
<p>   - DOM操作時のtextContent使用</p><p>2. <strong>CSRF対策</strong></p>
<p>   - カスタムヘッダーによるCSRFトークン送信</p>
<p>   - SameSite Cookieの活用（サーバー側）</p>
<p>   - リクエストの origin 検証</p><p>3. <strong>ユーザビリティ</strong></p>
<p>   - 自動トークンリフレッシュ</p>
<p>   - タブ切り替え時の状態確認</p>
<p>   - エラー時の適切なフィードバック</p><p>4. <strong>実装の詳細</strong></p>
<p>   - 重複リフレッシュの防止</p>
<p>   - 401エラーの自動リトライ</p>
<p>   - セキュアなエラーハンドリング</p><h2>問題3：無効化システムの設計</h2><h3>解答</h3><p><pre><code>python</p>
<h1>1000万ユーザー規模のトークン無効化システム設計</h1><p>class ScalableTokenRevocationSystem:
<p>    """</p>
<p>    大規模トークン無効化システム</p>
    
<p>    要件:</p>
<p>    - 1000万ユーザー</p>
<p>    - レイテンシ < 10ms</p>
<p>    - 高可用性（99.99%）</p>
<p>    - コスト最適化</p>
<p>    """</p>
    
<p>    def __init__(self):</p>
<p>        self.architecture = self._design_architecture()</p>
<p>        self.implementation = self._implement_system()</p>
    
<p>    def _design_architecture(self):</p>
<p>        """システムアーキテクチャの設計"""</p>
        
<p>        return {</p>
<p>            'overview': '''</p>
<p>            ┌─────────────┐     ┌──────────────┐     ┌─────────────┐</p>
<p>            │   Client    │────▶│ API Gateway  │────▶│ Auth Service│</p>
<p>            └─────────────┘     └──────────────┘     └─────────────┘</p>
<p>                                        │                     │</p>
<p>                                        ▼                     ▼</p>
<p>                              ┌─────────────────┐    ┌──────────────┐</p>
<p>                              │  Local Cache    │    │ Redis Cluster│</p>
<p>                              │   (In-Memory)   │    │  (Primary)   │</p>
<p>                              └─────────────────┘    └──────────────┘</p>
<p>                                        │                     │</p>
<p>                                        ▼                     ▼</p>
<p>                              ┌─────────────────┐    ┌──────────────┐</p>
<p>                              │ Bloom Filter    │    │  DynamoDB    │</p>
<p>                              │  (Probabilistic)│    │  (Backup)    │</p>
<p>                              └─────────────────┘    └──────────────┘</p>
<p>            ''',</p>
            
<p>            'components': {</p>
<p>                'api_gateway': {</p>
<p>                    'purpose': 'エントリーポイント、初期フィルタリング',</p>
<p>                    'technology': 'AWS API Gateway / Kong',</p>
<p>                    'features': [</p>
<p>                        'レート制限',</p>
<p>                        'ローカルキャッシュ（1分）',</p>
<p>                        '基本的なトークン検証'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'local_cache': {</p>
<p>                    'purpose': '超高速アクセス用キャッシュ',</p>
<p>                    'technology': 'Go gcache / Caffeine (Java)',</p>
<p>                    'config': {</p>
<p>                        'size': '100MB per instance',</p>
<p>                        'ttl': '60 seconds',</p>
<p>                        'eviction': 'LRU'</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'bloom_filter': {</p>
<p>                    'purpose': '存在しないトークンの高速除外',</p>
<p>                    'technology': 'Redis BloomFilter',</p>
<p>                    'config': {</p>
<p>                        'false_positive_rate': 0.001,</p>
<p>                        'expected_elements': 50_000_000,</p>
<p>                        'memory_usage': '~90MB'</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'redis_cluster': {</p>
<p>                    'purpose': 'プライマリ無効化ストア',</p>
<p>                    'topology': {</p>
<p>                        'shards': 10,</p>
<p>                        'replicas_per_shard': 2,</p>
<p>                        'total_nodes': 30</p>
<p>                    },</p>
<p>                    'features': [</p>
<p>                        'パーティショニング（CRC16）',</p>
<p>                        '自動フェイルオーバー',</p>
<p>                        'パイプライニング対応'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'dynamodb': {</p>
<p>                    'purpose': '永続化とディザスタリカバリ',</p>
<p>                    'config': {</p>
<p>                        'read_capacity': 5000,</p>
<p>                        'write_capacity': 1000,</p>
<p>                        'on_demand': True</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def _implement_system(self):</p>
<p>        """実装の詳細"""</p>
        
<p>        return {</p>
<p>            'token_check_flow': '''</p>
<p>            async def check_token_revocation(token_jti: str) -> bool:</p>
<p>                """</p>
<p>                トークン無効化チェックフロー</p>
<p>                目標レイテンシ: < 10ms</p>
<p>                """</p>
                
<p>                # Level 1: ローカルキャッシュ (< 0.1ms)</p>
<p>                if local_cache.contains(f"revoked:{token_jti}"):</p>
<p>                    return True</p>
                
<p>                # Level 2: Bloom Filter (< 1ms)</p>
<p>                if not bloom_filter.might_contain(token_jti):</p>
<p>                    # 確実に存在しない</p>
<p>                    return False</p>
                
<p>                # Level 3: Redis Cluster (< 5ms)</p>
<p>                try:</p>
<p>                    is_revoked = await redis_cluster.exists(</p>
<p>                        f"revoked:{token_jti}"</p>
<p>                    )</p>
                    
<p>                    # ローカルキャッシュに結果を保存</p>
<p>                    if is_revoked:</p>
<p>                        local_cache.set(</p>
<p>                            f"revoked:{token_jti}", </p>
<p>                            True, </p>
<p>                            ttl=60</p>
<p>                        )</p>
                    
<p>                    return is_revoked</p>
                    
<p>                except RedisTimeoutError:</p>
<p>                    # Level 4: DynamoDB フォールバック (< 10ms)</p>
<p>                    return await check_dynamodb_fallback(token_jti)</p>
<p>            ''',</p>
            
<p>            'revocation_flow': '''</p>
<p>            async def revoke_token(token_jti: str, user_id: str, reason: str):</p>
<p>                """トークン無効化フロー"""</p>
                
<p>                revocation_data = {</p>
<p>                    'jti': token_jti,</p>
<p>                    'user_id': user_id,</p>
<p>                    'revoked_at': time.time(),</p>
<p>                    'reason': reason</p>
<p>                }</p>
                
<p>                # 並行実行で高速化</p>
<p>                await asyncio.gather(</p>
<p>                    # Redis への書き込み</p>
<p>                    redis_cluster.setex(</p>
<p>                        f"revoked:{token_jti}",</p>
<p>                        86400,  # 24時間</p>
<p>                        json.dumps(revocation_data)</p>
<p>                    ),</p>
                    
<p>                    # Bloom Filter への追加</p>
<p>                    bloom_filter.add(token_jti),</p>
                    
<p>                    # DynamoDB への非同期書き込み</p>
<p>                    queue_dynamodb_write(revocation_data),</p>
                    
<p>                    # キャッシュの無効化</p>
<p>                    broadcast_cache_invalidation(token_jti)</p>
<p>                )</p>
<p>            ''',</p>
            
<p>            'optimization_strategies': {</p>
<p>                'batching': '''</p>
<p>                # バッチ処理による効率化</p>
<p>                class RevocationBatcher:</p>
<p>                    def __init__(self):</p>
<p>                        self.batch = []</p>
<p>                        self.lock = asyncio.Lock()</p>
<p>                        self.flush_task = None</p>
                    
<p>                    async def add_revocation(self, token_jti: str):</p>
<p>                        async with self.lock:</p>
<p>                            self.batch.append(token_jti)</p>
                            
<p>                            if len(self.batch) >= 100:</p>
<p>                                await self._flush()</p>
<p>                            elif not self.flush_task:</p>
<p>                                self.flush_task = asyncio.create_task(</p>
<p>                                    self._scheduled_flush()</p>
<p>                                )</p>
                    
<p>                    async def _flush(self):</p>
<p>                        if not self.batch:</p>
<p>                            return</p>
                        
<p>                        # パイプライン実行</p>
<p>                        pipeline = redis_cluster.pipeline()</p>
<p>                        for jti in self.batch:</p>
<p>                            pipeline.setex(f"revoked:{jti}", 86400, "1")</p>
                        
<p>                        await pipeline.execute()</p>
<p>                        self.batch.clear()</p>
<p>                ''',</p>
                
<p>                'connection_pooling': '''</p>
<p>                # コネクションプール最適化</p>
<p>                redis_pool = ConnectionPool(</p>
<p>                    max_connections=1000,</p>
<p>                    max_connections_per_node=100,</p>
<p>                    socket_keepalive=True,</p>
<p>                    socket_keepalive_options={</p>
<p>                        1: 1,  # TCP_KEEPIDLE</p>
<p>                        2: 1,  # TCP_KEEPINTVL</p>
<p>                        3: 3,  # TCP_KEEPCNT</p>
<p>                    }</p>
<p>                )</p>
<p>                ''',</p>
                
<p>                'circuit_breaker': '''</p>
<p>                # サーキットブレーカーパターン</p>
<p>                class RedisCircuitBreaker:</p>
<p>                    def __init__(self):</p>
<p>                        self.failure_count = 0</p>
<p>                        self.last_failure_time = 0</p>
<p>                        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN</p>
                    
<p>                    async def call(self, func, <em>args, </em>*kwargs):</p>
<p>                        if self.state == 'OPEN':</p>
<p>                            if time.time() - self.last_failure_time > 30:</p>
<p>                                self.state = 'HALF_OPEN'</p>
<p>                            else:</p>
<p>                                raise CircuitOpenError()</p>
                        
<p>                        try:</p>
<p>                            result = await func(<em>args, </em>*kwargs)</p>
<p>                            self._on_success()</p>
<p>                            return result</p>
<p>                        except Exception as e:</p>
<p>                            self._on_failure()</p>
<p>                            raise</p>
<p>                '''</p>
<p>            }</p>
<p>        }</p>
    
<p>    def calculate_cost_optimization(self):</p>
<p>        """コスト最適化の計算"""</p>
        
<p>        return {</p>
<p>            'redis_cluster': {</p>
<p>                'instance_type': 'cache.r6g.xlarge',</p>
<p>                'instances': 30,</p>
<p>                'monthly_cost': '$150 * 30 = $4,500',</p>
<p>                'optimization': [</p>
<p>                    'リザーブドインスタンスで30%削減',</p>
<p>                    'オフピーク時のスケールダウン'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'dynamodb': {</p>
<p>                'storage': '10GB',</p>
<p>                'monthly_cost': '$250',</p>
<p>                'optimization': [</p>
<p>                    'オンデマンド料金でコスト変動に対応',</p>
<p>                    'TTLによる自動削除でストレージ削減'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'data_transfer': {</p>
<p>                'monthly_estimate': '$500',</p>
<p>                'optimization': [</p>
<p>                    'VPCエンドポイントで転送料金削減',</p>
<p>                    'キャッシュヒット率向上'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'total_monthly_cost': '$5,250',</p>
<p>            'cost_per_user': '$0.000525'</p>
<p>        }</p>
    
<p>    def monitoring_and_alerting(self):</p>
<p>        """監視とアラート設定"""</p>
        
<p>        return {</p>
<p>            'metrics': {</p>
<p>                'latency': {</p>
<p>                    'p50': '< 2ms',</p>
<p>                    'p95': '< 8ms',</p>
<p>                    'p99': '< 10ms',</p>
<p>                    'alert_threshold': 'p99 > 15ms for 5 minutes'</p>
<p>                },</p>
                
<p>                'availability': {</p>
<p>                    'target': '99.99%',</p>
<p>                    'measurement': 'successful_checks / total_checks',</p>
<p>                    'alert_threshold': '< 99.95% for 5 minutes'</p>
<p>                },</p>
                
<p>                'cache_hit_rate': {</p>
<p>                    'target': '> 95%',</p>
<p>                    'layers': {</p>
<p>                        'local_cache': '> 60%',</p>
<p>                        'bloom_filter': '> 30%',</p>
<p>                        'redis': '> 5%'</p>
<p>                    }</p>
<p>                }</p>
<p>            },</p>
            
<p>            'dashboards': [</p>
<p>                'Token revocation latency',</p>
<p>                'System availability',</p>
<p>                'Cache performance',</p>
<p>                'Error rates',</p>
<p>                'Cost tracking'</p>
<p>            ]</p>
<p>        }</p>
<p></code></pre></p><h3>設計のポイント</h3><p>1. <strong>マルチレイヤーキャッシング</strong></p>
<p>   - ローカルキャッシュで60%以上のリクエストを処理</p>
<p>   - Bloom Filterで存在しないトークンを高速除外</p>
<p>   - Redis Clusterで分散処理</p><p>2. <strong>スケーラビリティ</strong></p>
<p>   - 水平スケーリング可能な設計</p>
<p>   - シャーディングによる負荷分散</p>
<p>   - 非同期処理による高速化</p><p>3. <strong>障害時の動作</strong></p>
<p>   - Circuit Breakerパターンでカスケード障害を防止</p>
<p>   - DynamoDBへのフォールバック</p>
<p>   - グレースフルデグラデーション</p><p>4. <strong>コスト最適化</strong></p>
<p>   - 効率的なキャッシング戦略</p>
<p>   - 適切なインスタンスサイズ選択</p>
<p>   - 自動スケーリングの活用</p><h2>問題4：セキュリティ監査</h2><h3>解答</h3><p><pre><code>python</p>
<h1>既存JWT実装のセキュリティ監査レポート</h1><p>class JWTSecurityAudit:
<p>    """JWT実装のセキュリティ監査"""</p>
    
<p>    def __init__(self):</p>
<p>        self.vulnerabilities = []</p>
<p>        self.risk_matrix = {}</p>
        
<p>    def audit_jwt_implementation(self, codebase):</p>
<p>        """包括的なセキュリティ監査の実施"""</p>
        
<p>        audit_report = {</p>
<p>            'executive_summary': self._executive_summary(),</p>
<p>            'vulnerabilities': self._identify_vulnerabilities(),</p>
<p>            'risk_assessment': self._assess_risks(),</p>
<p>            'recommendations': self._provide_recommendations(),</p>
<p>            'implementation_priority': self._prioritize_fixes()</p>
<p>        }</p>
        
<p>        return audit_report</p>
    
<p>    def _identify_vulnerabilities(self):</p>
<p>        """脆弱性の特定"""</p>
        
<p>        return [</p>
<p>            {</p>
<p>                'id': 'VULN-001',</p>
<p>                'title': 'アルゴリズムコンフュージョン攻撃への脆弱性',</p>
<p>                'severity': 'CRITICAL',</p>
<p>                'description': '''</p>
<p>                実装がalg="none"を受け入れる可能性がある。</p>
<p>                攻撃者が署名なしトークンを作成可能。</p>
<p>                ''',</p>
<p>                'affected_code': '''</p>
<p>                # 脆弱なコード</p>
<p>                def verify_token(token, secret):</p>
<p>                    header = decode_header(token)</p>
<p>                    if header['alg'] == 'none':</p>
<p>                        return decode_without_verification(token)</p>
<p>                    # ...</p>
<p>                ''',</p>
<p>                'exploitation': '''</p>
<p>                # 攻撃例</p>
<p>                malicious_token = base64url_encode('{"alg":"none"}') + '.' + </p>
<p>                                 base64url_encode('{"user_id":"admin"}') + '.'</p>
<p>                ''',</p>
<p>                'cve_reference': 'CVE-2015-2951'</p>
<p>            },</p>
            
<p>            {</p>
<p>                'id': 'VULN-002',</p>
<p>                'title': '弱い秘密鍵の使用',</p>
<p>                'severity': 'HIGH',</p>
<p>                'description': '''</p>
<p>                HS256で短い秘密鍵（< 256 bits）を使用。</p>
<p>                ブルートフォース攻撃に脆弱。</p>
<p>                ''',</p>
<p>                'affected_code': '''</p>
<p>                SECRET_KEY = "mysecret123"  # 11文字 = 88 bits</p>
<p>                ''',</p>
<p>                'mitigation': '''</p>
<p>                import secrets</p>
<p>                SECRET_KEY = secrets.token_hex(32)  # 256 bits</p>
<p>                '''</p>
<p>            },</p>
            
<p>            {</p>
<p>                'id': 'VULN-003',</p>
<p>                'title': 'トークン有効期限の未検証',</p>
<p>                'severity': 'HIGH',</p>
<p>                'description': '''</p>
<p>                exp クレームの検証が実装されていない。</p>
<p>                期限切れトークンが永続的に有効。</p>
<p>                ''',</p>
<p>                'affected_code': '''</p>
<p>                def verify_token(token):</p>
<p>                    payload = jwt.decode(token, verify=False)  # 危険！</p>
<p>                    return payload</p>
<p>                '''</p>
<p>            },</p>
            
<p>            {</p>
<p>                'id': 'VULN-004',</p>
<p>                'title': 'JTI（JWT ID）の未実装',</p>
<p>                'severity': 'MEDIUM',</p>
<p>                'description': '''</p>
<p>                トークンの一意性が保証されない。</p>
<p>                リプレイ攻撃への対策不足。</p>
<p>                ''',</p>
<p>                'recommendation': '''</p>
<p>                payload['jti'] = str(uuid.uuid4())</p>
<p>                payload['iat'] = int(time.time())</p>
<p>                '''</p>
<p>            },</p>
            
<p>            {</p>
<p>                'id': 'VULN-005',</p>
<p>                'title': 'クライアント側でのトークン生成',</p>
<p>                'severity': 'CRITICAL',</p>
<p>                'description': '''</p>
<p>                秘密鍵がクライアントコードに含まれている。</p>
<p>                任意のトークン作成が可能。</p>
<p>                ''',</p>
<p>                'affected_code': '''</p>
<p>                // client.js - 絶対にダメ！</p>
<p>                const token = jwt.sign(payload, 'secret123');</p>
<p>                '''</p>
<p>            },</p>
            
<p>            {</p>
<p>                'id': 'VULN-006',</p>
<p>                'title': 'Kid Header Injection',</p>
<p>                'severity': 'HIGH',</p>
<p>                'description': '''</p>
<p>                kid（Key ID）ヘッダーの検証不足。</p>
<p>                SQLインジェクションやパストラバーサルの可能性。</p>
<p>                ''',</p>
<p>                'vulnerable_pattern': '''</p>
<p>                key = load_key_from_db(f"SELECT key FROM keys WHERE id = '{kid}'")</p>
<p>                '''</p>
<p>            }</p>
<p>        ]</p>
    
<p>    def _assess_risks(self):</p>
<p>        """リスク評価"""</p>
        
<p>        return {</p>
<p>            'risk_matrix': {</p>
<p>                'critical': {</p>
<p>                    'count': 2,</p>
<p>                    'items': ['VULN-001', 'VULN-005'],</p>
<p>                    'business_impact': '完全な認証バイパス、全データへの不正アクセス',</p>
<p>                    'likelihood': 'HIGH',</p>
<p>                    'risk_score': 10</p>
<p>                },</p>
<p>                'high': {</p>
<p>                    'count': 3,</p>
<p>                    'items': ['VULN-002', 'VULN-003', 'VULN-006'],</p>
<p>                    'business_impact': 'セッションハイジャック、権限昇格',</p>
<p>                    'likelihood': 'MEDIUM',</p>
<p>                    'risk_score': 7</p>
<p>                },</p>
<p>                'medium': {</p>
<p>                    'count': 1,</p>
<p>                    'items': ['VULN-004'],</p>
<p>                    'business_impact': 'トークン管理の複雑化、監査困難',</p>
<p>                    'likelihood': 'LOW',</p>
<p>                    'risk_score': 4</p>
<p>                }</p>
<p>            },</p>
            
<p>            'overall_risk': 'CRITICAL',</p>
            
<p>            'compliance_impact': {</p>
<p>                'gdpr': '個人データ保護違反のリスク',</p>
<p>                'pci_dss': 'requirement 6.5.10 違反',</p>
<p>                'iso27001': 'A.14.2.5 セキュアシステム開発の不備'</p>
<p>            }</p>
<p>        }</p>
    
<p>    def _provide_recommendations(self):</p>
<p>        """改善提案"""</p>
        
<p>        return {</p>
<p>            'immediate_actions': [</p>
<p>                {</p>
<p>                    'action': 'アルゴリズムホワイトリストの実装',</p>
<p>                    'code': '''</p>
<p>                    ALLOWED_ALGORITHMS = ['RS256', 'ES256']</p>
                    
<p>                    def verify_token(token, public_key):</p>
<p>                        return jwt.decode(</p>
<p>                            token, </p>
<p>                            public_key, </p>
<p>                            algorithms=ALLOWED_ALGORITHMS</p>
<p>                        )</p>
<p>                    ''',</p>
<p>                    'effort': '2 hours',</p>
<p>                    'risk_reduction': 'CRITICAL → LOW'</p>
<p>                },</p>
                
<p>                {</p>
<p>                    'action': '強力な秘密鍵への移行',</p>
<p>                    'implementation': '''</p>
<p>                    # 1. 新しい鍵の生成</p>
<p>                    openssl rand -hex 32 > jwt_secret.key</p>
                    
<p>                    # 2. 環境変数での管理</p>
<p>                    JWT_SECRET=$(cat jwt_secret.key)</p>
                    
<p>                    # 3. キーローテーションの実装</p>
<p>                    class KeyRotation:</p>
<p>                        def __init__(self):</p>
<p>                            self.current_key = load_from_vault('jwt/current')</p>
<p>                            self.previous_key = load_from_vault('jwt/previous')</p>
                        
<p>                        def verify(self, token):</p>
<p>                            try:</p>
<p>                                return jwt.decode(token, self.current_key)</p>
<p>                            except:</p>
<p>                                return jwt.decode(token, self.previous_key)</p>
<p>                    ''',</p>
<p>                    'effort': '4 hours'</p>
<p>                }</p>
<p>            ],</p>
            
<p>            'medium_term_improvements': [</p>
<p>                {</p>
<p>                    'action': 'JWTライブラリのアップグレード',</p>
<p>                    'rationale': '既知の脆弱性の修正',</p>
<p>                    'steps': [</p>
<p>                        'ライブラリバージョンの確認',</p>
<p>                        'テスト環境での検証',</p>
<p>                        '段階的なロールアウト'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                {</p>
<p>                    'action': 'トークン無効化システムの実装',</p>
<p>                    'components': [</p>
<p>                        'Redisベースのブラックリスト',</p>
<p>                        'JTIによるトークン追跡',</p>
<p>                        '自動クリーンアップ'</p>
<p>                    ]</p>
<p>                }</p>
<p>            ],</p>
            
<p>            'long_term_strategy': [</p>
<p>                'OAuth 2.0 + OpenID Connectへの移行検討',</p>
<p>                'ハードウェアセキュリティモジュール（HSM）の導入',</p>
<p>                'Zero Trust Architectureの採用'</p>
<p>            ]</p>
<p>        }</p>
    
<p>    def _prioritize_fixes(self):</p>
<p>        """実装優先度"""</p>
        
<p>        return {</p>
<p>            'phase_1_immediate': {</p>
<p>                'duration': '1 week',</p>
<p>                'tasks': [</p>
<p>                    'アルゴリズムコンフュージョンの修正',</p>
<p>                    'クライアント側トークン生成の削除',</p>
<p>                    '秘密鍵の強化'</p>
<p>                ],</p>
<p>                'risk_reduction': '70%'</p>
<p>            },</p>
            
<p>            'phase_2_short_term': {</p>
<p>                'duration': '2 weeks',</p>
<p>                'tasks': [</p>
<p>                    'トークン有効期限の適切な検証',</p>
<p>                    'JTI実装による一意性保証',</p>
<p>                    'セキュリティヘッダーの追加'</p>
<p>                ],</p>
<p>                'risk_reduction': '20%'</p>
<p>            },</p>
            
<p>            'phase_3_medium_term': {</p>
<p>                'duration': '1 month',</p>
<p>                'tasks': [</p>
<p>                    'トークン無効化システム',</p>
<p>                    'キーローテーション',</p>
<p>                    '包括的なテストスイート'</p>
<p>                ],</p>
<p>                'risk_reduction': '10%'</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h3>監査結果のサマリー</h3><p>1. <strong>重大な脆弱性</strong>：アルゴリズムコンフュージョンとクライアント側トークン生成</p>
<p>2. <strong>リスク評価</strong>：現状はCRITICALレベル、即時対応が必要</p>
<p>3. <strong>改善提案</strong>：段階的な修正計画で1ヶ月以内にリスクを許容レベルまで低減</p>
<p>4. <strong>実装優先度</strong>：セキュリティクリティカルな項目から順次対応</p><h2>問題5：マイグレーション計画</h2><h3>解答</h3><p><pre><code>python</p>
<h1>セッションベース認証からJWT認証への段階的移行計画</h1><p>class AuthenticationMigrationPlan:
<p>    """認証方式の段階的移行計画"""</p>
    
<p>    def __init__(self):</p>
<p>        self.migration_phases = self._define_phases()</p>
<p>        self.rollback_procedures = self._define_rollback()</p>
        
<p>    def _define_phases(self):</p>
<p>        """移行フェーズの定義"""</p>
        
<p>        return {</p>
<p>            'phase_0_preparation': {</p>
<p>                'duration': '2 weeks',</p>
<p>                'description': '移行準備とインフラ整備',</p>
<p>                'tasks': [</p>
<p>                    {</p>
<p>                        'task': 'JWT実装の開発とテスト',</p>
<p>                        'implementation': '''</p>
<p>                        # デュアル認証ミドルウェアの実装</p>
<p>                        class DualAuthMiddleware:</p>
<p>                            def __init__(self):</p>
<p>                                self.session_auth = SessionAuthentication()</p>
<p>                                self.jwt_auth = JWTAuthentication()</p>
<p>                                self.migration_config = MigrationConfig()</p>
                            
<p>                            async def authenticate(self, request):</p>
<p>                                # 移行フラグをチェック</p>
<p>                                user_id = self._extract_user_id(request)</p>
<p>                                migration_status = self.migration_config.get_status(user_id)</p>
                                
<p>                                if migration_status == 'jwt_enabled':</p>
<p>                                    # JWT認証を試行</p>
<p>                                    user = await self.jwt_auth.authenticate(request)</p>
<p>                                    if user:</p>
<p>                                        return user</p>
                                
<p>                                # セッション認証にフォールバック</p>
<p>                                return await self.session_auth.authenticate(request)</p>
<p>                        '''</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'task': '監視ダッシュボードの構築',</p>
<p>                        'metrics': [</p>
<p>                            'auth_method_distribution',</p>
<p>                            'migration_progress',</p>
<p>                            'error_rates_by_method',</p>
<p>                            'performance_comparison'</p>
<p>                        ]</p>
<p>                    }</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'phase_1_canary': {</p>
<p>                'duration': '1 week',</p>
<p>                'description': '社内ユーザーでのカナリーテスト',</p>
<p>                'percentage': '0.1%',</p>
<p>                'implementation': '''</p>
<p>                # カナリーデプロイメント設定</p>
<p>                class CanaryMigration:</p>
<p>                    def __init__(self):</p>
<p>                        self.canary_users = set()</p>
<p>                        self.metrics = MetricsCollector()</p>
                    
<p>                    def should_use_jwt(self, user_id):</p>
<p>                        # 社内ユーザーのみ</p>
<p>                        if self.is_internal_user(user_id):</p>
<p>                            self.canary_users.add(user_id)</p>
<p>                            return True</p>
<p>                        return False</p>
                    
<p>                    def collect_metrics(self, user_id, auth_method, success, latency):</p>
<p>                        self.metrics.record({</p>
<p>                            'user_id': user_id,</p>
<p>                            'method': auth_method,</p>
<p>                            'success': success,</p>
<p>                            'latency': latency,</p>
<p>                            'timestamp': time.time()</p>
<p>                        })</p>
<p>                ''',</p>
<p>                'success_criteria': {</p>
<p>                    'error_rate': '< 0.1%',</p>
<p>                    'latency_p95': '< 50ms',</p>
<p>                    'user_complaints': 0</p>
<p>                }</p>
<p>            },</p>
            
<p>            'phase_2_gradual_rollout': {</p>
<p>                'duration': '4 weeks',</p>
<p>                'description': '段階的な全ユーザー展開',</p>
<p>                'rollout_schedule': [</p>
<p>                    {'week': 1, 'percentage': '5%', 'segment': 'power_users'},</p>
<p>                    {'week': 2, 'percentage': '20%', 'segment': 'active_users'},</p>
<p>                    {'week': 3, 'percentage': '50%', 'segment': 'regular_users'},</p>
<p>                    {'week': 4, 'percentage': '100%', 'segment': 'all_users'}</p>
<p>                ],</p>
<p>                'implementation': '''</p>
<p>                class GradualRollout:</p>
<p>                    def __init__(self):</p>
<p>                        self.rollout_config = {</p>
<p>                            'current_percentage': 0,</p>
<p>                            'user_segments': {},</p>
<p>                            'feature_flags': FeatureFlagService()</p>
<p>                        }</p>
                    
<p>                    async def migrate_user_batch(self, percentage, segment):</p>
<p>                        # ユーザーセグメントの選択</p>
<p>                        users = await self.select_users(segment, percentage)</p>
                        
<p>                        for user in users:</p>
<p>                            try:</p>
<p>                                # セッションからJWTへの変換</p>
<p>                                session_data = await self.get_session_data(user.id)</p>
<p>                                jwt_tokens = await self.create_jwt_tokens(user, session_data)</p>
                                
<p>                                # 新しい認証方式を有効化</p>
<p>                                await self.enable_jwt_auth(user.id)</p>
                                
<p>                                # 通知を送信</p>
<p>                                await self.notify_user(user, jwt_tokens)</p>
                                
<p>                            except Exception as e:</p>
<p>                                await self.handle_migration_error(user, e)</p>
                    
<p>                    async def create_jwt_tokens(self, user, session_data):</p>
<p>                        """セッションデータからJWTトークンを生成"""</p>
<p>                        return {</p>
<p>                            'access_token': self.jwt_service.create_access_token({</p>
<p>                                'user_id': user.id,</p>
<p>                                'email': user.email,</p>
<p>                                'roles': session_data.get('roles', []),</p>
<p>                                'session_id': session_data.get('session_id')  # 移行追跡用</p>
<p>                            }),</p>
<p>                            'refresh_token': self.jwt_service.create_refresh_token({</p>
<p>                                'user_id': user.id,</p>
<p>                                'migration_date': datetime.utcnow().isoformat()</p>
<p>                            })</p>
<p>                        }</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'phase_3_session_deprecation': {</p>
<p>                'duration': '2 weeks',</p>
<p>                'description': 'セッション認証の段階的廃止',</p>
<p>                'steps': [</p>
<p>                    {</p>
<p>                        'step': 'read_only_sessions',</p>
<p>                        'description': '新規セッション作成の停止',</p>
<p>                        'implementation': '''</p>
<p>                        class SessionDeprecation:</p>
<p>                            def create_session(self, user):</p>
<p>                                # 新規セッションの作成を防ぐ</p>
<p>                                logger.warning(f"Session creation attempted for user {user.id}")</p>
                                
<p>                                # JWTにリダイレクト</p>
<p>                                return self.create_jwt_instead(user)</p>
                            
<p>                            def extend_session(self, session_id):</p>
<p>                                # 既存セッションの延長は許可（一時的）</p>
<p>                                if self.is_valid_legacy_session(session_id):</p>
<p>                                    return self.extend_with_warning(session_id)</p>
                                
<p>                                raise SessionDeprecatedError()</p>
<p>                        '''</p>
<p>                    }</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'phase_4_cleanup': {</p>
<p>                'duration': '1 week',</p>
<p>                'description': 'クリーンアップと最適化',</p>
<p>                'tasks': [</p>
<p>                    'セッション関連コードの削除',</p>
<p>                    'データベースのクリーンアップ',</p>
<p>                    'ドキュメントの更新',</p>
<p>                    'パフォーマンスチューニング'</p>
<p>                ]</p>
<p>            }</p>
<p>        }</p>
    
<p>    def _define_rollback(self):</p>
<p>        """ロールバック手順の定義"""</p>
        
<p>        return {</p>
<p>            'triggers': [</p>
<p>                'error_rate > 1%',</p>
<p>                'latency_p95 > 200ms',</p>
<p>                'security_incident',</p>
<p>                'major_user_complaints'</p>
<p>            ],</p>
            
<p>            'procedures': {</p>
<p>                'immediate_rollback': '''</p>
<p>                async def emergency_rollback():</p>
<p>                    # 1. Feature Flagの即時切り替え</p>
<p>                    await feature_flags.disable('jwt_authentication')</p>
                    
<p>                    # 2. トラフィックの切り替え</p>
<p>                    await load_balancer.route_all_to('session_auth_servers')</p>
                    
<p>                    # 3. キャッシュのクリア</p>
<p>                    await cache.clear_pattern('jwt:*')</p>
                    
<p>                    # 4. アラート送信</p>
<p>                    await alert_team('Emergency rollback initiated')</p>
<p>                ''',</p>
                
<p>                'data_recovery': '''</p>
<p>                async def recover_user_sessions():</p>
<p>                    # JWTからセッションへの逆変換</p>
<p>                    affected_users = await get_jwt_only_users()</p>
                    
<p>                    for user in affected_users:</p>
<p>                        jwt_data = await extract_jwt_claims(user)</p>
<p>                        session = await recreate_session(jwt_data)</p>
<p>                        await notify_user_rollback(user)</p>
<p>                '''</p>
<p>            }</p>
<p>        }</p>
    
<p>    def performance_impact_assessment(self):</p>
<p>        """性能影響の評価"""</p>
        
<p>        return {</p>
<p>            'expected_improvements': {</p>
<p>                'latency': {</p>
<p>                    'session_auth_p50': '20ms',</p>
<p>                    'jwt_auth_p50': '5ms',</p>
<p>                    'improvement': '75%'</p>
<p>                },</p>
<p>                'throughput': {</p>
<p>                    'session_auth_rps': '10,000',</p>
<p>                    'jwt_auth_rps': '50,000',</p>
<p>                    'improvement': '400%'</p>
<p>                },</p>
<p>                'resource_usage': {</p>
<p>                    'session_storage': '50GB',</p>
<p>                    'jwt_storage': '1GB',</p>
<p>                    'reduction': '98%'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'monitoring_plan': '''</p>
<p>            # Grafanaダッシュボード設定</p>
<p>            dashboards:</p>
<p>              - name: "Auth Migration Metrics"</p>
<p>                panels:</p>
<p>                  - title: "Auth Method Distribution"</p>
<p>                    query: |</p>
<p>                      sum by (method) (</p>
<p>                        rate(auth_requests_total[5m])</p>
<p>                      )</p>
                  
<p>                  - title: "Error Rates by Method"</p>
<p>                    query: |</p>
<p>                      sum by (method) (</p>
<p>                        rate(auth_errors_total[5m])</p>
<p>                      ) / </p>
<p>                      sum by (method) (</p>
<p>                        rate(auth_requests_total[5m])</p>
<p>                      )</p>
                  
<p>                  - title: "Migration Progress"</p>
<p>                    query: |</p>
<p>                      count(user_auth_method{method="jwt"}) / </p>
<p>                      count(user_auth_method)</p>
<p>            '''</p>
<p>        }</p>
<p></code></pre></p><h3>移行計画のポイント</h3><p>1. <strong>段階的移行戦略</strong></p>
<p>   - カナリーデプロイメントから開始</p>
<p>   - セグメント別の段階的展開</p>
<p>   - 常にロールバック可能な状態を維持</p><p>2. <strong>後方互換性の維持</strong></p>
<p>   - デュアル認証システムの実装</p>
<p>   - 既存セッションの尊重</p>
<p>   - グレースフルな移行</p><p>3. <strong>ロールバック手順</strong></p>
<p>   - 明確なトリガー条件</p>
<p>   - 自動化されたロールバック</p>
<p>   - データ整合性の保証</p><p>4. <strong>性能影響の評価</strong></p>
<p>   - 詳細なメトリクス収集</p>
<p>   - A/Bテストによる検証</p>
<p>   - 継続的なモニタリング</p><h2>チャレンジ問題：分散環境でのトークン管理</h2><h3>解答</h3><p><pre><code>yaml</p>
<h1>マイクロサービス環境でのトークン管理システム設計</h1><p>apiVersion: v1
<p>kind: Architecture</p>
<p>metadata:</p>
<p>  name: distributed-token-management</p>
<p>spec:</p>
<p>  overview: |</p>
<p>    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐</p>
<p>    │   Client    │────▶│ API Gateway │────▶│Auth Service │</p>
<p>    └─────────────┘     └─────────────┘     └─────────────┘</p>
<p>                               │                      │</p>
<p>                               ▼                      ▼</p>
<p>                        ┌──────────────┐      ┌───────────┐</p>
<p>                        │Service Mesh  │      │Token Store│</p>
<p>                        │  (Istio)     │      │ (Redis)   │</p>
<p>                        └──────────────┘      └───────────┘</p>
<p>                               │</p>
<p>            ┌──────────────────┼──────────────────┐</p>
<p>            ▼                  ▼                  ▼</p>
<p>    ┌───────────────┐  ┌───────────────┐  ┌───────────────┐</p>
<p>    │ User Service │  │Order Service  │  │Payment Service│</p>
<p>    └───────────────┘  └───────────────┘  └───────────────┘</p>
<p></code></pre></p><p><pre><code>python</p>
<h1>分散トークン管理システムの実装</h1><p>class DistributedTokenManagement:
<p>    """マイクロサービス環境でのトークン管理"""</p>
    
<p>    def __init__(self):</p>
<p>        self.architecture = self._design_architecture()</p>
<p>        self.implementation = self._implement_system()</p>
        
<p>    def _design_architecture(self):</p>
<p>        """システムアーキテクチャ"""</p>
        
<p>        return {</p>
<p>            'components': {</p>
<p>                'api_gateway': {</p>
<p>                    'responsibility': 'エントリーポイント、初期認証',</p>
<p>                    'implementation': '''</p>
<p>                    # Kong Gateway設定</p>
<p>                    plugins:</p>
<p>                      - name: jwt</p>
<p>                        config:</p>
<p>                          uri_param_names: []</p>
<p>                          cookie_names: []</p>
<p>                          header_names:</p>
<p>                            - authorization</p>
<p>                          claims_to_verify:</p>
<p>                            - exp</p>
<p>                          maximum_expiration: 900</p>
                          
<p>                      - name: request-transformer</p>
<p>                        config:</p>
<p>                          add:</p>
<p>                            headers:</p>
<p>                              - X-User-ID:$(jwt.sub)</p>
<p>                              - X-User-Roles:$(jwt.roles)</p>
<p>                              - X-Request-ID:$(request_id)</p>
<p>                    '''</p>
<p>                },</p>
                
<p>                'auth_service': {</p>
<p>                    'responsibility': 'トークン発行、検証、管理',</p>
<p>                    'implementation': '''</p>
<p>                    from fastapi import FastAPI, Depends</p>
<p>                    from typing import Optional</p>
<p>                    import asyncio</p>
                    
<p>                    class AuthService:</p>
<p>                        def __init__(self):</p>
<p>                            self.token_store = RedisTokenStore()</p>
<p>                            self.key_manager = DistributedKeyManager()</p>
<p>                            self.event_bus = EventBus()</p>
                            
<p>                        async def issue_service_token(self, </p>
<p>                                                    service_name: str,</p>
<p>                                                    target_service: str) -> str:</p>
<p>                            """サービス間認証用トークンの発行"""</p>
                            
<p>                            # サービスの検証</p>
<p>                            if not await self.verify_service(service_name):</p>
<p>                                raise UnauthorizedError()</p>
                            
<p>                            # 短命なトークンを発行</p>
<p>                            token_data = {</p>
<p>                                'iss': 'auth-service',</p>
<p>                                'sub': service_name,</p>
<p>                                'aud': target_service,</p>
<p>                                'exp': int(time.time() + 60),  # 1分</p>
<p>                                'jti': str(uuid.uuid4()),</p>
<p>                                'scope': self.get_service_scope(service_name)</p>
<p>                            }</p>
                            
<p>                            # 分散キー管理から鍵を取得</p>
<p>                            signing_key = await self.key_manager.get_current_key()</p>
                            
<p>                            token = jwt.encode(token_data, signing_key, algorithm='RS256')</p>
                            
<p>                            # イベント発行</p>
<p>                            await self.event_bus.publish('token.issued', {</p>
<p>                                'service': service_name,</p>
<p>                                'target': target_service,</p>
<p>                                'jti': token_data['jti']</p>
<p>                            })</p>
                            
<p>                            return token</p>
                        
<p>                        async def propagate_token(self, </p>
<p>                                                user_token: str,</p>
<p>                                                target_services: List[str]) -> Dict:</p>
<p>                            """ユーザートークンの伝播"""</p>
                            
<p>                            # オリジナルトークンの検証</p>
<p>                            user_claims = await self.verify_token(user_token)</p>
                            
<p>                            # 各サービス用の派生トークンを生成</p>
<p>                            derived_tokens = {}</p>
                            
<p>                            for service in target_services:</p>
<p>                                derived_token = await self.create_derived_token(</p>
<p>                                    user_claims, </p>
<p>                                    service</p>
<p>                                )</p>
<p>                                derived_tokens[service] = derived_token</p>
                            
<p>                            return derived_tokens</p>
                        
<p>                        async def create_derived_token(self, </p>
<p>                                                     original_claims: Dict,</p>
<p>                                                     target_service: str) -> str:</p>
<p>                            """派生トークンの生成"""</p>
                            
<p>                            # 必要最小限の情報のみ含める</p>
<p>                            derived_claims = {</p>
<p>                                'iss': 'auth-service',</p>
<p>                                'sub': original_claims['sub'],</p>
<p>                                'aud': target_service,</p>
<p>                                'original_jti': original_claims['jti'],</p>
<p>                                'exp': min(</p>
<p>                                    original_claims['exp'],</p>
<p>                                    int(time.time() + 300)  # 最大5分</p>
<p>                                ),</p>
<p>                                'scope': self.filter_scope_for_service(</p>
<p>                                    original_claims.get('scope', []),</p>
<p>                                    target_service</p>
<p>                                )</p>
<p>                            }</p>
                            
<p>                            return jwt.encode(</p>
<p>                                derived_claims,</p>
<p>                                self.signing_key,</p>
<p>                                algorithm='RS256'</p>
<p>                            )</p>
<p>                    '''</p>
<p>                },</p>
                
<p>                'service_mesh': {</p>
<p>                    'responsibility': 'サービス間通信の認証・認可',</p>
<p>                    'implementation': '''</p>
<p>                    # Istio設定</p>
<p>                    apiVersion: security.istio.io/v1beta1</p>
<p>                    kind: AuthorizationPolicy</p>
<p>                    metadata:</p>
<p>                      name: service-auth</p>
<p>                    spec:</p>
<p>                      selector:</p>
<p>                        matchLabels:</p>
<p>                          app: microservice</p>
<p>                      rules:</p>
<p>                      - from:</p>
<p>                        - source:</p>
<p>                            requestPrincipals: ["cluster.local/ns/default/sa/*"]</p>
<p>                        to:</p>
<p>                        - operation:</p>
<p>                            methods: ["GET", "POST"]</p>
<p>                        when:</p>
<p>                        - key: request.auth.claims[iss]</p>
<p>                          values: ["auth-service"]</p>
<p>                        - key: request.auth.claims[exp]</p>
<p>                          values: [">", "now"]</p>
                    
<p>                    ---</p>
<p>                    apiVersion: security.istio.io/v1beta1</p>
<p>                    kind: RequestAuthentication</p>
<p>                    metadata:</p>
<p>                      name: jwt-auth</p>
<p>                    spec:</p>
<p>                      selector:</p>
<p>                        matchLabels:</p>
<p>                          app: microservice</p>
<p>                      jwtRules:</p>
<p>                      - issuer: "auth-service"</p>
<p>                        jwksUri: "http://auth-service/jwks"</p>
<p>                        audiences:</p>
<p>                        - "user-service"</p>
<p>                        - "order-service"</p>
<p>                        - "payment-service"</p>
<p>                    '''</p>
<p>                },</p>
                
<p>                'token_store': {</p>
<p>                    'responsibility': '分散トークン状態管理',</p>
<p>                    'implementation': '''</p>
<p>                    class DistributedTokenStore:</p>
<p>                        def __init__(self):</p>
<p>                            self.redis_cluster = RedisCluster(</p>
<p>                                startup_nodes=[</p>
<p>                                    {"host": "redis-1", "port": 6379},</p>
<p>                                    {"host": "redis-2", "port": 6379},</p>
<p>                                    {"host": "redis-3", "port": 6379}</p>
<p>                                ],</p>
<p>                                decode_responses=True,</p>
<p>                                skip_full_coverage_check=True</p>
<p>                            )</p>
<p>                            self.consistency_level = 'eventual'</p>
                            
<p>                        async def store_token_state(self, jti: str, state: Dict):</p>
<p>                            """トークン状態の保存"""</p>
                            
<p>                            key = f"token:{jti}"</p>
                            
<p>                            # 分散ロックを取得</p>
<p>                            lock = await self.acquire_lock(key)</p>
                            
<p>                            try:</p>
<p>                                # CRDTを使用した状態管理</p>
<p>                                current_state = await self.get_state(key)</p>
<p>                                merged_state = self.merge_states(current_state, state)</p>
                                
<p>                                # パイプラインで原子性を保証</p>
<p>                                pipe = self.redis_cluster.pipeline()</p>
<p>                                pipe.hset(key, mapping=merged_state)</p>
<p>                                pipe.expire(key, 3600)  # 1時間</p>
<p>                                pipe.publish(f"token_update:{jti}", json.dumps(state))</p>
<p>                                await pipe.execute()</p>
                                
<p>                            finally:</p>
<p>                                await self.release_lock(lock)</p>
                        
<p>                        def merge_states(self, current: Dict, new: Dict) -> Dict:</p>
<p>                            """CRDT風の状態マージ"""</p>
                            
<p>                            merged = current.copy()</p>
                            
<p>                            for key, value in new.items():</p>
<p>                                if key == 'revoked':</p>
<p>                                    # revokedフラグは一度trueになったら変更不可</p>
<p>                                    merged[key] = current.get(key, False) or value</p>
<p>                                elif key == 'last_used':</p>
<p>                                    # タイムスタンプは最新を採用</p>
<p>                                    merged[key] = max(</p>
<p>                                        current.get(key, 0), </p>
<p>                                        value</p>
<p>                                    )</p>
<p>                                elif key == 'usage_count':</p>
<p>                                    # カウンターは加算</p>
<p>                                    merged[key] = current.get(key, 0) + value</p>
<p>                                else:</p>
<p>                                    merged[key] = value</p>
                            
<p>                            return merged</p>
<p>                    '''</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def _implement_system(self):</p>
<p>        """システム実装"""</p>
        
<p>        return {</p>
<p>            'service_authentication': '''</p>
<p>            # 各マイクロサービスでの実装</p>
<p>            class MicroserviceAuth:</p>
<p>                def __init__(self, service_name: str):</p>
<p>                    self.service_name = service_name</p>
<p>                    self.auth_client = AuthServiceClient()</p>
<p>                    self.token_cache = TTLCache(maxsize=1000, ttl=60)</p>
                    
<p>                async def make_authenticated_request(self, </p>
<p>                                                   target_service: str,</p>
<p>                                                   endpoint: str,</p>
<p>                                                   user_context: Optional[Dict] = None):</p>
<p>                    """認証付きサービス間リクエスト"""</p>
                    
<p>                    # サービストークンの取得（キャッシュ付き）</p>
<p>                    service_token = await self._get_service_token(target_service)</p>
                    
<p>                    headers = {</p>
<p>                        'Authorization': f'Bearer {service_token}',</p>
<p>                        'X-Service-Name': self.service_name,</p>
<p>                        'X-Request-ID': str(uuid.uuid4())</p>
<p>                    }</p>
                    
<p>                    # ユーザーコンテキストがある場合は伝播</p>
<p>                    if user_context:</p>
<p>                        propagated_token = await self._propagate_user_context(</p>
<p>                            user_context, </p>
<p>                            target_service</p>
<p>                        )</p>
<p>                        headers['X-User-Context'] = propagated_token</p>
                    
<p>                    # サーキットブレーカー付きリクエスト</p>
<p>                    async with CircuitBreaker(</p>
<p>                        failure_threshold=5,</p>
<p>                        recovery_timeout=30</p>
<p>                    ) as cb:</p>
<p>                        return await cb.call(</p>
<p>                            self._make_request,</p>
<p>                            target_service,</p>
<p>                            endpoint,</p>
<p>                            headers</p>
<p>                        )</p>
                
<p>                async def _get_service_token(self, target_service: str) -> str:</p>
<p>                    """サービストークンの取得（キャッシュ付き）"""</p>
                    
<p>                    cache_key = f"{self.service_name}:{target_service}"</p>
                    
<p>                    # キャッシュチェック</p>
<p>                    cached_token = self.token_cache.get(cache_key)</p>
<p>                    if cached_token:</p>
<p>                        return cached_token</p>
                    
<p>                    # 新規取得</p>
<p>                    token = await self.auth_client.get_service_token(</p>
<p>                        self.service_name,</p>
<p>                        target_service</p>
<p>                    )</p>
                    
<p>                    self.token_cache[cache_key] = token</p>
<p>                    return token</p>
<p>            ''',</p>
            
<p>            'monitoring_and_troubleshooting': '''</p>
<p>            # 分散トレーシングの実装</p>
<p>            class TokenTracingSystem:</p>
<p>                def __init__(self):</p>
<p>                    self.tracer = init_tracer('token-management')</p>
                    
<p>                def trace_token_flow(self, token_jti: str):</p>
<p>                    """トークンフローの追跡"""</p>
                    
<p>                    with self.tracer.start_span('token_flow') as span:</p>
<p>                        span.set_tag('token.jti', token_jti)</p>
                        
<p>                        # トークン発行の追跡</p>
<p>                        issue_span = self.tracer.start_span(</p>
<p>                            'token_issued',</p>
<p>                            child_of=span</p>
<p>                        )</p>
                        
<p>                        # サービス間伝播の追跡</p>
<p>                        propagation_spans = []</p>
<p>                        for service in self.get_token_usage(token_jti):</p>
<p>                            prop_span = self.tracer.start_span(</p>
<p>                                f'token_propagated_to_{service}',</p>
<p>                                child_of=span</p>
<p>                            )</p>
<p>                            propagation_spans.append(prop_span)</p>
                        
<p>                        # 無効化の追跡</p>
<p>                        if self.is_token_revoked(token_jti):</p>
<p>                            revoke_span = self.tracer.start_span(</p>
<p>                                'token_revoked',</p>
<p>                                child_of=span</p>
<p>                            )</p>
                
<p>                def create_monitoring_dashboard(self):</p>
<p>                    """監視ダッシュボードの設定"""</p>
                    
<p>                    return {</p>
<p>                        'metrics': [</p>
<p>                            {</p>
<p>                                'name': 'token_issued_total',</p>
<p>                                'type': 'counter',</p>
<p>                                'labels': ['service', 'token_type']</p>
<p>                            },</p>
<p>                            {</p>
<p>                                'name': 'token_validation_duration',</p>
<p>                                'type': 'histogram',</p>
<p>                                'labels': ['service', 'result']</p>
<p>                            },</p>
<p>                            {</p>
<p>                                'name': 'token_propagation_errors',</p>
<p>                                'type': 'counter',</p>
<p>                                'labels': ['source', 'target', 'error_type']</p>
<p>                            },</p>
<p>                            {</p>
<p>                                'name': 'active_tokens',</p>
<p>                                'type': 'gauge',</p>
<p>                                'labels': ['service']</p>
<p>                            }</p>
<p>                        ],</p>
                        
<p>                        'alerts': [</p>
<p>                            {</p>
<p>                                'name': 'HighTokenValidationLatency',</p>
<p>                                'expr': 'histogram_quantile(0.95, token_validation_duration) > 100',</p>
<p>                                'for': '5m',</p>
<p>                                'severity': 'warning'</p>
<p>                            },</p>
<p>                            {</p>
<p>                                'name': 'TokenPropagationFailure',</p>
<p>                                'expr': 'rate(token_propagation_errors[5m]) > 0.01',</p>
<p>                                'for': '5m',</p>
<p>                                'severity': 'critical'</p>
<p>                            }</p>
<p>                        ]</p>
<p>                    }</p>
<p>            '''</p>
<p>        }</p>
<p></code></pre></p><h3>設計のポイント</h3><p>1. <strong>サービス間認証</strong></p>
<p>   - 短命なサービストークン</p>
<p>   - mTLSとの組み合わせ</p>
<p>   - 最小権限の原則</p><p>2. <strong>トークンの伝播</strong></p>
<p>   - 派生トークンによるスコープ制限</p>
<p>   - コンテキスト情報の安全な伝達</p>
<p>   - 自動的な有効期限短縮</p><p>3. <strong>一貫性のある無効化</strong></p>
<p>   - 分散キャッシュによる状態共有</p>
<p>   - イベント駆動の無効化通知</p>
<p>   - 結果整合性の許容</p><p>4. <strong>監視とトラブルシューティング</strong></p>
<p>   - 分散トレーシングによる可視化</p>
<p>   - メトリクスベースのアラート</p>
<p>   - トークンライフサイクルの追跡</p>
            </div>
        </main>
    </div>
</body>
</html>