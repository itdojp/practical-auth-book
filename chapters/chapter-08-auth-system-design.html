<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第8章 認証システムの設計 - 実践 認証認可システム設計</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            overflow-x: hidden;
            width: 100%;
        }
        .book-layout {
            display: flex;
            min-height: 100vh;
            width: 100%;
            position: relative;
        }
        .book-sidebar {
            width: 280px;
            background-color: #fff;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
            position: fixed;
            height: 100vh;
        }
        .book-main {
            margin-left: 280px;
            flex: 1;
            padding: 40px;
            max-width: 900px;
        }
        .sidebar-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .nav-section {
            margin-bottom: 30px;
        }
        .nav-section-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }
        .nav-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .nav-link {
            display: block;
            padding: 8px 12px;
            color: #495057;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .nav-link:hover {
            background-color: #e9ecef;
            color: #007bff;
        }
        .nav-link.active {
            background-color: #007bff;
            color: white;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
            color: #6c757d;
            text-align: center;
        }
        @media (max-width: 768px) {
            .book-sidebar {
                display: none;
            }
            .book-main {
                margin-left: 0;
                padding: 15px;
                max-width: 100%;
                width: 100%;
                overflow-x: hidden;
            }
            .container {
                padding: 15px;
                margin: 0;
                box-shadow: none;
                border-radius: 0;
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }
            h1 {
                font-size: 1.8rem;
                line-height: 1.3;
            }
            h2 {
                font-size: 1.4rem;
                line-height: 1.3;
                margin-top: 2rem;
            }
            h3 {
                font-size: 1.2rem;
                line-height: 1.3;
                margin-top: 1.5rem;
            }
            /* コードブロックのモバイル最適化 */
            pre {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding: 12px;
                font-size: 0.85rem;
                line-height: 1.4;
                white-space: pre;
                word-wrap: normal;
                max-width: 100%;
                margin: 1rem 0;
            }
            code {
                font-size: 0.85rem;
                word-break: break-word;
                white-space: pre-wrap;
            }
            pre code {
                white-space: pre;
                word-break: normal;
            }
            /* テーブルのモバイル対応 */
            table {
                width: 100%;
                overflow-x: auto;
                display: block;
                white-space: nowrap;
            }
            table tbody {
                display: table;
                width: 100%;
            }
            /* リストの調整 */
            ul, ol {
                padding-left: 1.2rem;
            }
            li {
                margin-bottom: 0.3rem;
            }
            /* 画像の最適化 */
            img {
                max-width: 100%;
                height: auto;
                display: block;
                margin: 1rem auto;
            }
            /* 長いURLやテキストの折り返し */
            p {
                word-wrap: break-word;
                overflow-wrap: break-word;
                max-width: 100%;
            }
            /* ボックスモデルの調整 */
            * {
                box-sizing: border-box;
            }
            /* フォントサイズの調整 */
            body {
                font-size: 0.95rem;
                line-height: 1.6;
            }
        }
    </style>
</head>
<body>
    <div class="book-layout">
        <!-- Sidebar Navigation -->
        <aside class="book-sidebar">
            <div class="sidebar-title">
                <a href="/practical-auth-book/" style="color: inherit; text-decoration: none;">実践 認証認可システム設計</a>
            </div>
            
            <nav class="sidebar-nav">
                <div class="nav-section">
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/introduction" class="nav-link">はじめに</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第I部: 基礎概念編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-01-overview" class="nav-link">第1章: 認証認可の全体像</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-02-authentication" class="nav-link">第2章: 認証の基礎</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-03-authorization" class="nav-link">第3章: 認可の基礎</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第II部: プロトコルと標準編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-04-session" class="nav-link">第4章: セッション管理</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-05-token-auth" class="nav-link">第5章: トークンベース認証</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-06-oauth2" class="nav-link">第6章: OAuth 2.0</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-07-oidc-saml" class="nav-link">第7章: OpenID ConnectとSAML</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第III部: 実装編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-08-auth-system-design" class="nav-link">第8章: 認証システムの設計</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-09-microservices-auth" class="nav-link">第9章: マイクロサービスでの認証認可</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-10-implementation-patterns" class="nav-link">第10章: 実装パターンとベストプラクティス</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">第IV部: 応用編</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/chapters/chapter-11-security-threats" class="nav-link">第11章: セキュリティ脅威と対策</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-12-performance" class="nav-link">第12章: パフォーマンス最適化</a></li>
                        <li><a href="/practical-auth-book/chapters/chapter-13-future" class="nav-link">第13章: 認証技術の未来</a></li>
                    </ul>
                </div>

                <div class="nav-section">
                    <h3 class="nav-section-title">付録</h3>
                    <ul class="nav-list">
                        <li><a href="/practical-auth-book/appendices/appendix-a-libraries" class="nav-link">付録A: 主要ライブラリ・ツール一覧</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-b-troubleshooting" class="nav-link">付録B: トラブルシューティングガイド</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-c-glossary" class="nav-link">付録C: 用語集</a></li>
                        <li><a href="/practical-auth-book/appendices/appendix-d-references" class="nav-link">付録D: 参考文献・リソース</a></li>
                    </ul>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="book-main">
            <div class="container">
                </p><h1>第8章 認証システムの設計</h1><h2>なぜこの章が重要か</h2><p>優れた認証システムは、単に「動く」だけでは不十分です。セキュリティ、スケーラビリティ、ユーザビリティ、保守性のすべてを満たす必要があります。この章では、実際のプロダクション環境で使える認証システムを設計する方法を学びます。要件定義から始まり、データベース設計、API設計、そしてユーザー体験まで、認証システム設計の全工程を体系的に理解します。</p><h2>8.1 要件定義と設計の進め方</h2><h3>8.1.1 なぜ要件定義から始めるのか</h3><p><pre><code>python
<p>class AuthSystemRequirementsAnalysis:</p>
<p>    """認証システムの要件分析"""</p>
    
<p>    def explain_importance(self):</p>
<p>        """要件定義の重要性"""</p>
        
<p>        return {</p>
<p>            'common_mistakes': {</p>
<p>                'feature_creep': {</p>
<p>                    'problem': '機能の追加し過ぎ',</p>
<p>                    'example': '''</p>
<p>                    初期要件：メールとパスワードでログイン</p>
<p>                    ↓</p>
<p>                    追加1：ソーシャルログイン（5種類）</p>
<p>                    追加2：生体認証</p>
<p>                    追加3：パスワードレス</p>
<p>                    追加4：ブロックチェーン認証（？）</p>
                    
<p>                    結果：複雑で保守困難なシステム</p>
<p>                    ''',</p>
<p>                    'consequence': '開発期間の延長、バグの増加、UXの悪化'</p>
<p>                },</p>
                
<p>                'security_theater': {</p>
<p>                    'problem': '見かけだけのセキュリティ',</p>
<p>                    'example': '''</p>
<p>                    # 複雑なパスワードルール</p>
<p>                    - 大文字小文字数字記号必須</p>
<p>                    - 12文字以上</p>
<p>                    - 辞書に載っている単語禁止</p>
<p>                    - 30日ごとに変更必須</p>
                    
<p>                    結果：付箋にパスワードを書く</p>
<p>                    ''',</p>
<p>                    'consequence': 'ユーザビリティ低下、実質的なセキュリティ低下'</p>
<p>                },</p>
                
<p>                'over_engineering': {</p>
<p>                    'problem': '過度な設計',</p>
<p>                    'example': '''</p>
<p>                    想定ユーザー数：1000人</p>
<p>                    設計：</p>
<p>                    - マイクロサービス（10個）</p>
<p>                    - 分散データベース</p>
<p>                    - グローバル展開前提</p>
<p>                    - 毎秒100万リクエスト対応</p>
<p>                    ''',</p>
<p>                    'consequence': '不要な複雑性、高コスト、開発遅延'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'requirements_driven_design': {</p>
<p>                'principle': '要件が設計を決定する',</p>
<p>                'process': '''</p>
<p>                1. ビジネス要件の理解</p>
<p>                   └─ 何を守るのか？誰が使うのか？</p>
                
<p>                2. セキュリティ要件の定義</p>
<p>                   └─ 脅威モデル、コンプライアンス</p>
                
<p>                3. 技術要件の導出</p>
<p>                   └─ パフォーマンス、可用性、拡張性</p>
                
<p>                4. 制約条件の整理</p>
<p>                   └─ 予算、期間、既存システム</p>
                
<p>                5. 優先順位付け</p>
<p>                   └─ MVP、Phase1、将来拡張</p>
<p>                '''</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h3>8.1.2 要件定義のフレームワーク</h3><p><pre><code>python</p>
<p>class RequirementsFramework:</p>
<p>    """要件定義のフレームワーク"""</p>
    
<p>    def define_business_requirements(self):</p>
<p>        """ビジネス要件の定義"""</p>
        
<p>        return {</p>
<p>            'user_stories': {</p>
<p>                'template': 'As a [role], I want [feature] so that [benefit]',</p>
<p>                'examples': [</p>
<p>                    {</p>
<p>                        'story': 'As a customer, I want to login with my email so that I can access my account',</p>
<p>                        'acceptance_criteria': [</p>
<p>                            'Email and password fields are displayed',</p>
<p>                            'Invalid credentials show error message',</p>
<p>                            'Successful login redirects to dashboard',</p>
<p>                            'Session persists across page refreshes'</p>
<p>                        ]</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'story': 'As an admin, I want to disable user accounts so that I can prevent unauthorized access',</p>
<p>                        'acceptance_criteria': [</p>
<p>                            'Admin can search and find users',</p>
<p>                            'Disable action is logged',</p>
<p>                            'Disabled users cannot login',</p>
<p>                            'Users receive notification'</p>
<p>                        ]</p>
<p>                    }</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'business_metrics': {</p>
<p>                'user_experience': [</p>
<p>                    'Login success rate > 95%',</p>
<p>                    'Average login time < 5 seconds',</p>
<p>                    'Password reset completion rate > 80%'</p>
<p>                ],</p>
<p>                'security': [</p>
<p>                    'Account takeover rate < 0.01%',</p>
<p>                    'Brute force attacks blocked 100%',</p>
<p>                    'Security incidents < 1 per month'</p>
<p>                ],</p>
<p>                'operational': [</p>
<p>                    'Support tickets for login issues < 5%',</p>
<p>                    'System uptime > 99.9%',</p>
<p>                    'User onboarding time < 2 minutes'</p>
<p>                ]</p>
<p>            }</p>
<p>        }</p>
    
<p>    def define_security_requirements(self):</p>
<p>        """セキュリティ要件の定義"""</p>
        
<p>        return {</p>
<p>            'authentication_requirements': {</p>
<p>                'password_policy': {</p>
<p>                    'minimum_length': 12,</p>
<p>                    'complexity': 'NIST guidelines (no forced complexity)',</p>
<p>                    'history': 'Last 5 passwords cannot be reused',</p>
<p>                    'expiry': 'No forced expiry, risk-based prompts'</p>
<p>                },</p>
                
<p>                'mfa_requirements': {</p>
<p>                    'mandatory_for': ['admin_users', 'high_value_transactions'],</p>
<p>                    'optional_for': ['regular_users'],</p>
<p>                    'methods': ['totp', 'sms', 'push_notification'],</p>
<p>                    'backup_codes': True</p>
<p>                },</p>
                
<p>                'session_management': {</p>
<p>                    'idle_timeout': '30 minutes',</p>
<p>                    'absolute_timeout': '8 hours',</p>
<p>                    'concurrent_sessions': 'Limited to 5',</p>
<p>                    'device_tracking': True</p>
<p>                }</p>
<p>            },</p>
            
<p>            'threat_model': {</p>
<p>                'external_threats': [</p>
<p>                    {</p>
<p>                        'threat': 'Brute force attacks',</p>
<p>                        'mitigation': 'Rate limiting, account lockout, CAPTCHA'</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'threat': 'Credential stuffing',</p>
<p>                        'mitigation': 'Breach detection, unusual activity monitoring'</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'threat': 'Phishing',</p>
<p>                        'mitigation': 'Security keys, user education'</p>
<p>                    }</p>
<p>                ],</p>
                
<p>                'internal_threats': [</p>
<p>                    {</p>
<p>                        'threat': 'Insider access',</p>
<p>                        'mitigation': 'Audit logging, least privilege'</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'threat': 'Developer mistakes',</p>
<p>                        'mitigation': 'Security testing, code review'</p>
<p>                    }</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'compliance_requirements': {</p>
<p>                'gdpr': {</p>
<p>                    'data_minimization': True,</p>
<p>                    'right_to_deletion': True,</p>
<p>                    'consent_management': True,</p>
<p>                    'breach_notification': '72 hours'</p>
<p>                },</p>
<p>                'pci_dss': {</p>
<p>                    'applicable': 'If handling payment cards',</p>
<p>                    'requirements': ['Strong cryptography', 'Access control', 'Monitoring']</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def define_technical_requirements(self):</p>
<p>        """技術要件の定義"""</p>
        
<p>        return {</p>
<p>            'performance_requirements': {</p>
<p>                'response_time': {</p>
<p>                    'login_api': 'p95 < 200ms',</p>
<p>                    'token_validation': 'p95 < 50ms',</p>
<p>                    'user_lookup': 'p95 < 100ms'</p>
<p>                },</p>
                
<p>                'throughput': {</p>
<p>                    'peak_load': '1000 requests/second',</p>
<p>                    'sustained_load': '100 requests/second',</p>
<p>                    'concurrent_users': '10,000'</p>
<p>                },</p>
                
<p>                'scalability': {</p>
<p>                    'horizontal_scaling': True,</p>
<p>                    'auto_scaling': True,</p>
<p>                    'global_distribution': False  # Phase 2</p>
<p>                }</p>
<p>            },</p>
            
<p>            'availability_requirements': {</p>
<p>                'uptime_sla': '99.9%',</p>
<p>                'maintenance_window': 'Sunday 2-4 AM',</p>
<p>                'disaster_recovery': {</p>
<p>                    'rto': '1 hour',  # Recovery Time Objective</p>
<p>                    'rpo': '15 minutes'  # Recovery Point Objective</p>
<p>                },</p>
<p>                'degraded_mode': 'Read-only authentication if DB is down'</p>
<p>            },</p>
            
<p>            'integration_requirements': {</p>
<p>                'existing_systems': [</p>
<p>                    {</p>
<p>                        'system': 'User database',</p>
<p>                        'integration_type': 'Direct DB access',</p>
<p>                        'constraints': 'Read-only access'</p>
<p>                    },</p>
<p>                    {</p>
<p>                        'system': 'Email service',</p>
<p>                        'integration_type': 'API',</p>
<p>                        'use_cases': ['Password reset', 'MFA codes']</p>
<p>                    }</p>
<p>                ],</p>
                
<p>                'future_integrations': [</p>
<p>                    'LDAP/Active Directory',</p>
<p>                    'SAML IdP',</p>
<p>                    'OAuth providers'</p>
<p>                ]</p>
<p>            }</p>
<p>        }</p>
    
<p>    def prioritize_requirements(self):</p>
<p>        """要件の優先順位付け"""</p>
        
<p>        return {</p>
<p>            'moscow_method': {</p>
<p>                'must_have': [</p>
<p>                    'Email/password authentication',</p>
<p>                    'Secure password storage',</p>
<p>                    'Session management',</p>
<p>                    'Password reset',</p>
<p>                    'Basic rate limiting'</p>
<p>                ],</p>
                
<p>                'should_have': [</p>
<p>                    'MFA for admins',</p>
<p>                    'Account lockout',</p>
<p>                    'Audit logging',</p>
<p>                    'Remember me',</p>
<p>                    'CAPTCHA'</p>
<p>                ],</p>
                
<p>                'could_have': [</p>
<p>                    'Social login',</p>
<p>                    'Biometric authentication',</p>
<p>                    'Advanced threat detection',</p>
<p>                    'Self-service MFA'</p>
<p>                ],</p>
                
<p>                'wont_have': [</p>
<p>                    'Blockchain authentication',</p>
<p>                    'Quantum-resistant crypto',</p>
<p>                    'AI-based authentication'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'phased_approach': {</p>
<p>                'mvp': {</p>
<p>                    'timeline': '2 months',</p>
<p>                    'features': ['Basic auth', 'Password reset', 'Session management'],</p>
<p>                    'users': 'Internal beta'</p>
<p>                },</p>
                
<p>                'phase_1': {</p>
<p>                    'timeline': '3 months',</p>
<p>                    'features': ['MFA', 'Audit logging', 'Admin panel'],</p>
<p>                    'users': 'Limited release'</p>
<p>                },</p>
                
<p>                'phase_2': {</p>
<p>                    'timeline': '6 months',</p>
<p>                    'features': ['SSO', 'Advanced security', 'API expansion'],</p>
<p>                    'users': 'General availability'</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h3>8.1.3 設計プロセスの実践</h3><p><pre><code>python</p>
<p>class DesignProcess:</p>
<p>    """設計プロセスの実践"""</p>
    
<p>    def iterative_design_approach(self):</p>
<p>        """反復的な設計アプローチ"""</p>
        
<p>        return {</p>
<p>            'design_thinking_process': {</p>
<p>                'empathize': {</p>
<p>                    'activities': [</p>
<p>                        'User interviews',</p>
<p>                        'Support ticket analysis',</p>
<p>                        'Competitor analysis'</p>
<p>                    ],</p>
<p>                    'outputs': [</p>
<p>                        'User personas',</p>
<p>                        'Pain points',</p>
<p>                        'User journey maps'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'define': {</p>
<p>                    'activities': [</p>
<p>                        'Problem statement creation',</p>
<p>                        'Requirements prioritization',</p>
<p>                        'Success metrics definition'</p>
<p>                    ],</p>
<p>                    'outputs': [</p>
<p>                        'Problem statement',</p>
<p>                        'Requirements document',</p>
<p>                        'KPIs'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'ideate': {</p>
<p>                    'activities': [</p>
<p>                        'Brainstorming sessions',</p>
<p>                        'Architecture sketching',</p>
<p>                        'Technology evaluation'</p>
<p>                    ],</p>
<p>                    'outputs': [</p>
<p>                        'Solution options',</p>
<p>                        'Architecture diagrams',</p>
<p>                        'Tech stack recommendations'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'prototype': {</p>
<p>                    'activities': [</p>
<p>                        'Proof of concept',</p>
<p>                        'API design',</p>
<p>                        'UI mockups'</p>
<p>                    ],</p>
<p>                    'outputs': [</p>
<p>                        'Working prototype',</p>
<p>                        'API specification',</p>
<p>                        'UI designs'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'test': {</p>
<p>                    'activities': [</p>
<p>                        'Security testing',</p>
<p>                        'Performance testing',</p>
<p>                        'User testing'</p>
<p>                    ],</p>
<p>                    'outputs': [</p>
<p>                        'Test results',</p>
<p>                        'Feedback',</p>
<p>                        'Improvement recommendations'</p>
<p>                    ]</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def architectural_decisions(self):</p>
<p>        """アーキテクチャ決定"""</p>
        
<p>        return {</p>
<p>            'decision_record_template': {</p>
<p>                'title': 'ADR-001: Authentication Service Architecture',</p>
<p>                'status': 'Accepted',</p>
<p>                'context': '''</p>
<p>                We need to decide on the overall architecture for the authentication service.</p>
<p>                Current system has 10k users, expected to grow to 100k in 2 years.</p>
<p>                ''',</p>
                
<p>                'decision': '''</p>
<p>                We will use a monolithic architecture with modular design.</p>
<p>                Authentication logic will be in a separate service.</p>
<p>                Session storage will use Redis.</p>
<p>                ''',</p>
                
<p>                'consequences': '''</p>
<p>                Positive:</p>
<p>                - Simpler deployment and monitoring</p>
<p>                - Lower operational complexity</p>
<p>                - Faster time to market</p>
                
<p>                Negative:</p>
<p>                - Scaling requires scaling entire service</p>
<p>                - Technology choices affect entire service</p>
                
<p>                Mitigation:</p>
<p>                - Design with future microservices split in mind</p>
<p>                - Use clean architecture principles</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'key_decisions': [</p>
<p>                {</p>
<p>                    'decision': 'Stateless vs Stateful sessions',</p>
<p>                    'choice': 'Stateful with Redis',</p>
<p>                    'rationale': 'Better control over sessions, easier revocation'</p>
<p>                },</p>
<p>                {</p>
<p>                    'decision': 'Sync vs Async processing',</p>
<p>                    'choice': 'Sync for auth, async for audit/analytics',</p>
<p>                    'rationale': 'User experience vs system efficiency'</p>
<p>                },</p>
<p>                {</p>
<p>                    'decision': 'SQL vs NoSQL for user data',</p>
<p>                    'choice': 'PostgreSQL for users, Redis for sessions',</p>
<p>                    'rationale': 'ACID compliance for user data, speed for sessions'</p>
<p>                }</p>
<p>            ]</p>
<p>        }</p>
<p></code></pre></p><h2>8.2 データベース設計</h2><h3>8.2.1 認証システムのデータモデル</h3><p><pre><code>python</p>
<p>class AuthenticationDataModel:</p>
<p>    """認証システムのデータモデル"""</p>
    
<p>    def core_entities(self):</p>
<p>        """中核となるエンティティ"""</p>
        
<p>        return {</p>
<p>            'users_table': '''</p>
<p>            CREATE TABLE users (</p>
<p>                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>                email VARCHAR(255) UNIQUE NOT NULL,</p>
<p>                email_verified BOOLEAN DEFAULT FALSE,</p>
<p>                email_verified_at TIMESTAMP,</p>
                
<p>                -- パスワード関連</p>
<p>                password_hash VARCHAR(255),</p>
<p>                password_changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                password_reset_token VARCHAR(255),</p>
<p>                password_reset_expires_at TIMESTAMP,</p>
                
<p>                -- プロフィール</p>
<p>                username VARCHAR(50) UNIQUE,</p>
<p>                display_name VARCHAR(100),</p>
<p>                profile_picture_url VARCHAR(500),</p>
                
<p>                -- ステータス</p>
<p>                status VARCHAR(20) DEFAULT 'active' </p>
<p>                    CHECK (status IN ('active', 'inactive', 'suspended', 'deleted')),</p>
<p>                suspended_at TIMESTAMP,</p>
<p>                suspended_reason TEXT,</p>
<p>                deleted_at TIMESTAMP,</p>
                
<p>                -- メタデータ</p>
<p>                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                last_login_at TIMESTAMP,</p>
<p>                login_count INTEGER DEFAULT 0,</p>
                
<p>                -- セキュリティ</p>
<p>                mfa_enabled BOOLEAN DEFAULT FALSE,</p>
<p>                mfa_secret VARCHAR(255),</p>
<p>                backup_codes TEXT[], -- 暗号化して保存</p>
                
<p>                -- インデックス用</p>
<p>                created_at_date DATE GENERATED ALWAYS AS (DATE(created_at)) STORED</p>
<p>            );</p>
            
<p>            -- インデックス</p>
<p>            CREATE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;</p>
<p>            CREATE INDEX idx_users_status ON users(status) WHERE status != 'deleted';</p>
<p>            CREATE INDEX idx_users_created_at ON users(created_at_date);</p>
<p>            CREATE INDEX idx_users_last_login ON users(last_login_at) WHERE last_login_at IS NOT NULL;</p>
<p>            ''',</p>
            
<p>            'user_credentials_table': '''</p>
<p>            -- 複数の認証方式をサポート</p>
<p>            CREATE TABLE user_credentials (</p>
<p>                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>                user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p>
<p>                credential_type VARCHAR(50) NOT NULL,</p>
<p>                credential_id VARCHAR(255) NOT NULL,</p>
<p>                credential_public_key TEXT,</p>
<p>                credential_data JSONB,</p>
                
<p>                -- 使用状況</p>
<p>                last_used_at TIMESTAMP,</p>
<p>                use_count INTEGER DEFAULT 0,</p>
                
<p>                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
                
<p>                UNIQUE(user_id, credential_type, credential_id)</p>
<p>            );</p>
            
<p>            CREATE INDEX idx_credentials_user ON user_credentials(user_id);</p>
<p>            CREATE INDEX idx_credentials_type ON user_credentials(credential_type);</p>
<p>            ''',</p>
            
<p>            'sessions_table': '''</p>
<p>            -- アクティブセッション管理</p>
<p>            CREATE TABLE sessions (</p>
<p>                id VARCHAR(128) PRIMARY KEY,</p>
<p>                user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p>
                
<p>                -- セッション情報</p>
<p>                ip_address INET,</p>
<p>                user_agent TEXT,</p>
<p>                device_fingerprint VARCHAR(64),</p>
                
<p>                -- 時間管理</p>
<p>                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                expires_at TIMESTAMP NOT NULL,</p>
                
<p>                -- セッションデータ</p>
<p>                data JSONB DEFAULT '{}',</p>
                
<p>                -- セキュリティ</p>
<p>                is_mfa_verified BOOLEAN DEFAULT FALSE,</p>
<p>                mfa_verified_at TIMESTAMP</p>
<p>            );</p>
            
<p>            CREATE INDEX idx_sessions_user ON sessions(user_id);</p>
<p>            CREATE INDEX idx_sessions_expires ON sessions(expires_at);</p>
<p>            CREATE INDEX idx_sessions_device ON sessions(user_id, device_fingerprint);</p>
<p>            ''',</p>
            
<p>            'audit_logs_table': '''</p>
<p>            -- 監査ログ（パーティショニング推奨）</p>
<p>            CREATE TABLE audit_logs (</p>
<p>                id BIGSERIAL,</p>
<p>                user_id UUID,</p>
<p>                event_type VARCHAR(50) NOT NULL,</p>
<p>                event_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
                
<p>                -- コンテキスト情報</p>
<p>                ip_address INET,</p>
<p>                user_agent TEXT,</p>
<p>                session_id VARCHAR(128),</p>
                
<p>                -- イベント詳細</p>
<p>                event_data JSONB,</p>
                
<p>                -- 結果</p>
<p>                success BOOLEAN NOT NULL,</p>
<p>                error_code VARCHAR(50),</p>
<p>                error_message TEXT,</p>
                
<p>                PRIMARY KEY (event_timestamp, id)</p>
<p>            ) PARTITION BY RANGE (event_timestamp);</p>
            
<p>            -- 月次パーティション</p>
<p>            CREATE TABLE audit_logs_2024_01 PARTITION OF audit_logs</p>
<p>                FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');</p>
            
<p>            CREATE INDEX idx_audit_user_time ON audit_logs(user_id, event_timestamp);</p>
<p>            CREATE INDEX idx_audit_type_time ON audit_logs(event_type, event_timestamp);</p>
<p>            '''</p>
<p>        }</p>
    
<p>    def supporting_entities(self):</p>
<p>        """サポート用エンティティ"""</p>
        
<p>        return {</p>
<p>            'login_attempts': '''</p>
<p>            -- ログイン試行の追跡</p>
<p>            CREATE TABLE login_attempts (</p>
<p>                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>                email VARCHAR(255) NOT NULL,</p>
<p>                ip_address INET NOT NULL,</p>
                
<p>                attempt_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                success BOOLEAN NOT NULL,</p>
<p>                failure_reason VARCHAR(50),</p>
                
<p>                -- レート制限用</p>
<p>                attempt_count INTEGER DEFAULT 1,</p>
<p>                locked_until TIMESTAMP</p>
<p>            );</p>
            
<p>            CREATE INDEX idx_attempts_email_ip ON login_attempts(email, ip_address);</p>
<p>            CREATE INDEX idx_attempts_time ON login_attempts(attempt_time);</p>
            
<p>            -- 古いレコードの自動削除</p>
<p>            CREATE OR REPLACE FUNCTION cleanup_old_attempts() RETURNS void AS $$</p>
<p>            BEGIN</p>
<p>                DELETE FROM login_attempts </p>
<p>                WHERE attempt_time < CURRENT_TIMESTAMP - INTERVAL '7 days';</p>
<p>            END;</p>
<p>            $$ LANGUAGE plpgsql;</p>
<p>            ''',</p>
            
<p>            'device_tracking': '''</p>
<p>            -- デバイストラッキング</p>
<p>            CREATE TABLE user_devices (</p>
<p>                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>                user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p>
                
<p>                device_fingerprint VARCHAR(64) NOT NULL,</p>
<p>                device_name VARCHAR(100),</p>
<p>                device_type VARCHAR(50),</p>
                
<p>                -- 識別情報</p>
<p>                user_agent TEXT,</p>
<p>                platform VARCHAR(50),</p>
<p>                browser VARCHAR(50),</p>
                
<p>                -- 信頼状態</p>
<p>                is_trusted BOOLEAN DEFAULT FALSE,</p>
<p>                trusted_at TIMESTAMP,</p>
                
<p>                -- 使用状況</p>
<p>                first_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                login_count INTEGER DEFAULT 1,</p>
                
<p>                UNIQUE(user_id, device_fingerprint)</p>
<p>            );</p>
            
<p>            CREATE INDEX idx_devices_user ON user_devices(user_id);</p>
<p>            CREATE INDEX idx_devices_trusted ON user_devices(user_id) WHERE is_trusted = TRUE;</p>
<p>            ''',</p>
            
<p>            'oauth_tokens': '''</p>
<p>            -- OAuth/JWT トークン管理</p>
<p>            CREATE TABLE oauth_tokens (</p>
<p>                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>                user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p>
                
<p>                token_type VARCHAR(20) NOT NULL, -- 'access', 'refresh'</p>
<p>                token_hash VARCHAR(64) NOT NULL, -- SHA-256 hash</p>
                
<p>                client_id VARCHAR(100),</p>
<p>                scope TEXT,</p>
                
<p>                issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</p>
<p>                expires_at TIMESTAMP NOT NULL,</p>
<p>                revoked_at TIMESTAMP,</p>
                
<p>                -- リフレッシュトークン用</p>
<p>                refresh_token_hash VARCHAR(64),</p>
<p>                refresh_count INTEGER DEFAULT 0,</p>
                
<p>                UNIQUE(token_hash)</p>
<p>            );</p>
            
<p>            CREATE INDEX idx_tokens_user ON oauth_tokens(user_id);</p>
<p>            CREATE INDEX idx_tokens_expires ON oauth_tokens(expires_at) WHERE revoked_at IS NULL;</p>
<p>            '''</p>
<p>        }</p>
    
<p>    def data_integrity_patterns(self):</p>
<p>        """データ整合性パターン"""</p>
        
<p>        return {</p>
<p>            'soft_delete_pattern': '''</p>
<p>            -- ソフトデリートの実装</p>
<p>            CREATE OR REPLACE FUNCTION soft_delete_user(user_id UUID) </p>
<p>            RETURNS void AS $$</p>
<p>            BEGIN</p>
<p>                -- トランザクション内で実行</p>
<p>                UPDATE users </p>
<p>                SET </p>
<p>                    status = 'deleted',</p>
<p>                    deleted_at = CURRENT_TIMESTAMP,</p>
<p>                    email = email || ':deleted:' || extract(epoch from CURRENT_TIMESTAMP),</p>
<p>                    username = username || ':deleted:' || extract(epoch from CURRENT_TIMESTAMP)</p>
<p>                WHERE id = user_id;</p>
                
<p>                -- 関連セッションの削除</p>
<p>                DELETE FROM sessions WHERE user_id = user_id;</p>
                
<p>                -- 監査ログ</p>
<p>                INSERT INTO audit_logs (user_id, event_type, success, event_data)</p>
<p>                VALUES (user_id, 'user_deleted', true, '{"deleted_by": "system"}');</p>
<p>            END;</p>
<p>            $$ LANGUAGE plpgsql;</p>
<p>            ''',</p>
            
<p>            'password_history': '''</p>
<p>            -- パスワード履歴管理</p>
<p>            CREATE TABLE password_history (</p>
<p>                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),</p>
<p>                user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,</p>
<p>                password_hash VARCHAR(255) NOT NULL,</p>
<p>                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</p>
<p>            );</p>
            
<p>            CREATE INDEX idx_password_history_user ON password_history(user_id, created_at DESC);</p>
            
<p>            -- パスワード変更時のチェック</p>
<p>            CREATE OR REPLACE FUNCTION check_password_history(</p>
<p>                p_user_id UUID, </p>
<p>                p_new_password_hash VARCHAR</p>
<p>            ) RETURNS BOOLEAN AS $$</p>
<p>            DECLARE</p>
<p>                history_count INTEGER := 5; -- 最近5つのパスワードをチェック</p>
<p>            BEGIN</p>
<p>                RETURN NOT EXISTS (</p>
<p>                    SELECT 1 </p>
<p>                    FROM password_history </p>
<p>                    WHERE user_id = p_user_id </p>
<p>                        AND password_hash = p_new_password_hash</p>
<p>                    ORDER BY created_at DESC </p>
<p>                    LIMIT history_count</p>
<p>                );</p>
<p>            END;</p>
<p>            $$ LANGUAGE plpgsql;</p>
<p>            ''',</p>
            
<p>            'data_encryption': '''</p>
<p>            -- 機密データの暗号化</p>
            
<p>            -- PII暗号化用の拡張</p>
<p>            CREATE EXTENSION IF NOT EXISTS pgcrypto;</p>
            
<p>            -- 暗号化ヘルパー関数</p>
<p>            CREATE OR REPLACE FUNCTION encrypt_pii(plain_text TEXT, key_id TEXT)</p>
<p>            RETURNS TEXT AS $$</p>
<p>            DECLARE</p>
<p>                encryption_key BYTEA;</p>
<p>            BEGIN</p>
<p>                -- キー管理サービスから鍵を取得（実装は省略）</p>
<p>                encryption_key := get_encryption_key(key_id);</p>
                
<p>                RETURN encode(</p>
<p>                    pgp_sym_encrypt(plain_text, encryption_key::TEXT),</p>
<p>                    'base64'</p>
<p>                );</p>
<p>            END;</p>
<p>            $$ LANGUAGE plpgsql;</p>
            
<p>            CREATE OR REPLACE FUNCTION decrypt_pii(encrypted_text TEXT, key_id TEXT)</p>
<p>            RETURNS TEXT AS $$</p>
<p>            DECLARE</p>
<p>                encryption_key BYTEA;</p>
<p>            BEGIN</p>
<p>                encryption_key := get_encryption_key(key_id);</p>
                
<p>                RETURN pgp_sym_decrypt(</p>
<p>                    decode(encrypted_text, 'base64'),</p>
<p>                    encryption_key::TEXT</p>
<p>                );</p>
<p>            END;</p>
<p>            $$ LANGUAGE plpgsql;</p>
<p>            '''</p>
<p>        }</p>
<p></code></pre></p><h3>8.2.2 パフォーマンス最適化</h3><p><pre><code>python</p>
<p>class DatabasePerformanceOptimization:</p>
<p>    """データベースパフォーマンス最適化"""</p>
    
<p>    def indexing_strategy(self):</p>
<p>        """インデックス戦略"""</p>
        
<p>        return {</p>
<p>            'critical_indexes': {</p>
<p>                'authentication_queries': '''</p>
<p>                -- ログイン用の複合インデックス</p>
<p>                CREATE INDEX idx_users_login ON users(email, status) </p>
<p>                WHERE deleted_at IS NULL AND status = 'active';</p>
                
<p>                -- セッション検証用</p>
<p>                CREATE INDEX idx_sessions_validation ON sessions(id, user_id, expires_at)</p>
<p>                WHERE expires_at > CURRENT_TIMESTAMP;</p>
                
<p>                -- デバイス認証用</p>
<p>                CREATE INDEX idx_devices_auth ON user_devices(user_id, device_fingerprint, is_trusted);</p>
<p>                ''',</p>
                
<p>                'analytics_queries': '''</p>
<p>                -- 日次アクティブユーザー</p>
<p>                CREATE INDEX idx_audit_daily_active ON audit_logs(event_timestamp, user_id)</p>
<p>                WHERE event_type IN ('login_success', 'session_refresh');</p>
                
<p>                -- ログイン失敗分析</p>
<p>                CREATE INDEX idx_audit_failures ON audit_logs(event_timestamp, ip_address)</p>
<p>                WHERE event_type = 'login_failure' AND success = false;</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'partial_indexes': '''</p>
<p>            -- アクティブユーザーのみのインデックス</p>
<p>            CREATE INDEX idx_active_users_email ON users(email) </p>
<p>            WHERE status = 'active' AND deleted_at IS NULL;</p>
            
<p>            -- MFA有効ユーザー</p>
<p>            CREATE INDEX idx_mfa_users ON users(id) </p>
<p>            WHERE mfa_enabled = true AND status = 'active';</p>
            
<p>            -- 最近ログインしたユーザー</p>
<p>            CREATE INDEX idx_recent_login ON users(last_login_at) </p>
<p>            WHERE last_login_at > CURRENT_TIMESTAMP - INTERVAL '30 days';</p>
<p>            ''',</p>
            
<p>            'covering_indexes': '''</p>
<p>            -- セッション情報を含むインデックス</p>
<p>            CREATE INDEX idx_sessions_full ON sessions(id) </p>
<p>            INCLUDE (user_id, expires_at, is_mfa_verified);</p>
            
<p>            -- ユーザー認証情報を含むインデックス</p>
<p>            CREATE INDEX idx_users_auth ON users(email) </p>
<p>            INCLUDE (id, password_hash, status, mfa_enabled);</p>
<p>            '''</p>
<p>        }</p>
    
<p>    def query_optimization(self):</p>
<p>        """クエリ最適化"""</p>
        
<p>        return {</p>
<p>            'common_query_patterns': {</p>
<p>                'user_authentication': '''</p>
<p>                -- 最適化されたユーザー認証クエリ</p>
<p>                WITH user_auth AS (</p>
<p>                    SELECT </p>
<p>                        id, </p>
<p>                        password_hash, </p>
<p>                        status,</p>
<p>                        mfa_enabled,</p>
<p>                        (CURRENT_TIMESTAMP - last_login_at) as time_since_login</p>
<p>                    FROM users</p>
<p>                    WHERE email = $1 </p>
<p>                        AND deleted_at IS NULL</p>
<p>                        AND status IN ('active', 'inactive')</p>
<p>                    LIMIT 1</p>
<p>                )</p>
<p>                SELECT * FROM user_auth;</p>
                
<p>                -- EXPLAINプラン</p>
<p>                -- Index Scan using idx_users_login (cost=0.42..8.44)</p>
<p>                ''',</p>
                
<p>                'session_validation': '''</p>
<p>                -- 効率的なセッション検証</p>
<p>                SELECT </p>
<p>                    s.id,</p>
<p>                    s.user_id,</p>
<p>                    s.expires_at,</p>
<p>                    s.is_mfa_verified,</p>
<p>                    u.status as user_status,</p>
<p>                    u.mfa_enabled</p>
<p>                FROM sessions s</p>
<p>                INNER JOIN users u ON s.user_id = u.id</p>
<p>                WHERE s.id = $1</p>
<p>                    AND s.expires_at > CURRENT_TIMESTAMP</p>
<p>                    AND u.status = 'active'</p>
<p>                    AND u.deleted_at IS NULL;</p>
<p>                ''',</p>
                
<p>                'concurrent_sessions': '''</p>
<p>                -- ユーザーの同時セッション取得</p>
<p>                SELECT </p>
<p>                    id,</p>
<p>                    ip_address,</p>
<p>                    user_agent,</p>
<p>                    created_at,</p>
<p>                    last_accessed_at,</p>
<p>                    CASE </p>
<p>                        WHEN device_fingerprint = $2 THEN true </p>
<p>                        ELSE false </p>
<p>                    END as is_current_device</p>
<p>                FROM sessions</p>
<p>                WHERE user_id = $1</p>
<p>                    AND expires_at > CURRENT_TIMESTAMP</p>
<p>                ORDER BY last_accessed_at DESC</p>
<p>                LIMIT 10;</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'batch_operations': '''</p>
<p>            -- バッチセッションクリーンアップ</p>
<p>            DELETE FROM sessions</p>
<p>            WHERE expires_at < CURRENT_TIMESTAMP</p>
<p>                AND id = ANY(</p>
<p>                    SELECT id </p>
<p>                    FROM sessions </p>
<p>                    WHERE expires_at < CURRENT_TIMESTAMP</p>
<p>                    LIMIT 1000</p>
<p>                );</p>
            
<p>            -- バッチ監査ログアーカイブ</p>
<p>            WITH moved_rows AS (</p>
<p>                DELETE FROM audit_logs</p>
<p>                WHERE event_timestamp < CURRENT_TIMESTAMP - INTERVAL '90 days'</p>
<p>                RETURNING *</p>
<p>            )</p>
<p>            INSERT INTO audit_logs_archive </p>
<p>            SELECT * FROM moved_rows;</p>
<p>            '''</p>
<p>        }</p>
    
<p>    def scaling_patterns(self):</p>
<p>        """スケーリングパターン"""</p>
        
<p>        return {</p>
<p>            'read_replica_strategy': {</p>
<p>                'setup': '''</p>
<p>                -- マスター/レプリカ構成</p>
<p>                -- マスター: 書き込み専用</p>
<p>                -- レプリカ: 読み込み専用</p>
                
<p>                -- アプリケーションレベルでの振り分け</p>
<p>                class DatabaseRouter:</p>
<p>                    def __init__(self):</p>
<p>                        self.master = psycopg2.connect(master_dsn)</p>
<p>                        self.replica = psycopg2.connect(replica_dsn)</p>
                    
<p>                    def execute_write(self, query, params):</p>
<p>                        with self.master.cursor() as cur:</p>
<p>                            cur.execute(query, params)</p>
<p>                            self.master.commit()</p>
                    
<p>                    def execute_read(self, query, params):</p>
<p>                        with self.replica.cursor() as cur:</p>
<p>                            cur.execute(query, params)</p>
<p>                            return cur.fetchall()</p>
<p>                ''',</p>
                
<p>                'consistency_handling': '''</p>
<p>                -- レプリケーションラグの対処</p>
                
<p>                -- 書き込み直後の読み込みはマスターから</p>
<p>                def authenticate_user(email, password):</p>
<p>                    # マスターから読み込み（一貫性保証）</p>
<p>                    user = db.master.query("SELECT * FROM users WHERE email = %s", [email])</p>
                    
<p>                    if verify_password(password, user.password_hash):</p>
<p>                        # セッション作成（マスターに書き込み）</p>
<p>                        session = create_session(user.id)</p>
<p>                        return session</p>
                    
<p>                def get_user_profile(user_id):</p>
<p>                    # レプリカから読み込み（少しの遅延は許容）</p>
<p>                    return db.replica.query("SELECT * FROM users WHERE id = %s", [user_id])</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'sharding_strategy': {</p>
<p>                'user_sharding': '''</p>
<p>                -- ユーザーIDベースのシャーディング</p>
                
<p>                CREATE OR REPLACE FUNCTION get_shard_for_user(user_id UUID) </p>
<p>                RETURNS INTEGER AS $$</p>
<p>                BEGIN</p>
<p>                    -- UUIDの最初の8文字をハッシュ</p>
<p>                    RETURN abs(hashtext(user_id::text)) % 4; -- 4シャード</p>
<p>                END;</p>
<p>                $$ LANGUAGE plpgsql;</p>
                
<p>                -- シャードごとのテーブル</p>
<p>                CREATE TABLE users_shard_0 () INHERITS (users);</p>
<p>                CREATE TABLE users_shard_1 () INHERITS (users);</p>
<p>                CREATE TABLE users_shard_2 () INHERITS (users);</p>
<p>                CREATE TABLE users_shard_3 () INHERITS (users);</p>
                
<p>                -- ルーティング関数</p>
<p>                CREATE OR REPLACE FUNCTION route_user_insert() </p>
<p>                RETURNS TRIGGER AS $$</p>
<p>                DECLARE</p>
<p>                    shard_num INTEGER;</p>
<p>                BEGIN</p>
<p>                    shard_num := get_shard_for_user(NEW.id);</p>
                    
<p>                    EXECUTE format('INSERT INTO users_shard_%s VALUES ($1.*)', shard_num)</p>
<p>                    USING NEW;</p>
                    
<p>                    RETURN NULL;</p>
<p>                END;</p>
<p>                $$ LANGUAGE plpgsql;</p>
<p>                ''',</p>
                
<p>                'session_sharding': '''</p>
<p>                -- セッションは別のデータストア（Redis）を推奨</p>
                
<p>                class SessionStore:</p>
<p>                    def __init__(self):</p>
<p>                        self.redis_cluster = RedisCluster(</p>
<p>                            startup_nodes=[</p>
<p>                                {"host": "redis-1", "port": 6379},</p>
<p>                                {"host": "redis-2", "port": 6379},</p>
<p>                                {"host": "redis-3", "port": 6379}</p>
<p>                            ]</p>
<p>                        )</p>
                    
<p>                    def save_session(self, session_id, data, ttl=1800):</p>
<p>                        key = f"session:{session_id}"</p>
<p>                        self.redis_cluster.setex(key, ttl, json.dumps(data))</p>
                    
<p>                    def get_session(self, session_id):</p>
<p>                        key = f"session:{session_id}"</p>
<p>                        data = self.redis_cluster.get(key)</p>
<p>                        return json.loads(data) if data else None</p>
<p>                '''</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h2>8.3 API設計とエンドポイント</h2><h3>8.3.1 RESTful API設計</h3><p><pre><code>python</p>
<p>class AuthenticationAPIDesign:</p>
<p>    """認証API設計"""</p>
    
<p>    def api_principles(self):</p>
<p>        """API設計原則"""</p>
        
<p>        return {</p>
<p>            'design_principles': {</p>
<p>                'consistency': '一貫性のある命名とレスポンス形式',</p>
<p>                'statelessness': 'RESTfulの原則に従う',</p>
<p>                'versioning': '後方互換性を考慮したバージョニング',</p>
<p>                'security': 'セキュリティファースト',</p>
<p>                'documentation': 'OpenAPI仕様での文書化'</p>
<p>            },</p>
            
<p>            'naming_conventions': {</p>
<p>                'resources': {</p>
<p>                    'pattern': '/api/v1/{resource}/{id}/{sub-resource}',</p>
<p>                    'examples': [</p>
<p>                        '/api/v1/auth/login',</p>
<p>                        '/api/v1/users/{id}',</p>
<p>                        '/api/v1/users/{id}/sessions',</p>
<p>                        '/api/v1/users/{id}/mfa'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'http_methods': {</p>
<p>                    'GET': '取得',</p>
<p>                    'POST': '作成',</p>
<p>                    'PUT': '完全な更新',</p>
<p>                    'PATCH': '部分的な更新',</p>
<p>                    'DELETE': '削除'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'response_format': {</p>
<p>                'success_response': {</p>
<p>                    'status': 'success',</p>
<p>                    'data': {},</p>
<p>                    'meta': {</p>
<p>                        'timestamp': '2024-01-15T10:30:00Z',</p>
<p>                        'version': 'v1'</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'error_response': {</p>
<p>                    'status': 'error',</p>
<p>                    'error': {</p>
<p>                        'code': 'AUTH_001',</p>
<p>                        'message': 'Invalid credentials',</p>
<p>                        'details': 'The email or password is incorrect',</p>
<p>                        'timestamp': '2024-01-15T10:30:00Z'</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'pagination_response': {</p>
<p>                    'status': 'success',</p>
<p>                    'data': [],</p>
<p>                    'pagination': {</p>
<p>                        'page': 1,</p>
<p>                        'per_page': 20,</p>
<p>                        'total': 100,</p>
<p>                        'total_pages': 5</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def authentication_endpoints(self):</p>
<p>        """認証エンドポイント"""</p>
        
<p>        return {</p>
<p>            'login': {</p>
<p>                'endpoint': 'POST /api/v1/auth/login',</p>
<p>                'description': 'ユーザーログイン',</p>
<p>                'request': {</p>
<p>                    'headers': {</p>
<p>                        'Content-Type': 'application/json',</p>
<p>                        'X-Device-Fingerprint': 'optional-device-id'</p>
<p>                    },</p>
<p>                    'body': {</p>
<p>                        'email': 'user@example.com',</p>
<p>                        'password': 'secure_password',</p>
<p>                        'remember_me': False</p>
<p>                    }</p>
<p>                },</p>
<p>                'response': {</p>
<p>                    'success': {</p>
<p>                        'status': 'success',</p>
<p>                        'data': {</p>
<p>                            'user': {</p>
<p>                                'id': 'uuid',</p>
<p>                                'email': 'user@example.com',</p>
<p>                                'name': 'John Doe'</p>
<p>                            },</p>
<p>                            'session': {</p>
<p>                                'token': 'session_token',</p>
<p>                                'expires_at': '2024-01-15T18:30:00Z'</p>
<p>                            },</p>
<p>                            'requires_mfa': False</p>
<p>                        }</p>
<p>                    },</p>
<p>                    'mfa_required': {</p>
<p>                        'status': 'success',</p>
<p>                        'data': {</p>
<p>                            'mfa_token': 'temporary_token',</p>
<p>                            'mfa_methods': ['totp', 'sms'],</p>
<p>                            'expires_at': '2024-01-15T10:35:00Z'</p>
<p>                        }</p>
<p>                    },</p>
<p>                    'errors': {</p>
<p>                        '401': {</p>
<p>                            'code': 'INVALID_CREDENTIALS',</p>
<p>                            'message': 'Invalid email or password'</p>
<p>                        },</p>
<p>                        '423': {</p>
<p>                            'code': 'ACCOUNT_LOCKED',</p>
<p>                            'message': 'Account is temporarily locked',</p>
<p>                            'retry_after': 300</p>
<p>                        }</p>
<p>                    }</p>
<p>                },</p>
<p>                'implementation': '''</p>
<p>                @app.route('/api/v1/auth/login', methods=['POST'])</p>
<p>                @rate_limit(calls=5, period=300)  # 5 attempts per 5 minutes</p>
<p>                def login():</p>
<p>                    data = request.get_json()</p>
                    
<p>                    # 入力検証</p>
<p>                    errors = validate_login_input(data)</p>
<p>                    if errors:</p>
<p>                        return jsonify({</p>
<p>                            'status': 'error',</p>
<p>                            'error': {</p>
<p>                                'code': 'VALIDATION_ERROR',</p>
<p>                                'details': errors</p>
<p>                            }</p>
<p>                        }), 400</p>
                    
<p>                    # レート制限チェック</p>
<p>                    if is_rate_limited(data['email'], request.remote_addr):</p>
<p>                        return jsonify({</p>
<p>                            'status': 'error',</p>
<p>                            'error': {</p>
<p>                                'code': 'RATE_LIMITED',</p>
<p>                                'message': 'Too many attempts',</p>
<p>                                'retry_after': 300</p>
<p>                            }</p>
<p>                        }), 429</p>
                    
<p>                    # 認証処理</p>
<p>                    user = authenticate_user(data['email'], data['password'])</p>
<p>                    if not user:</p>
<p>                        record_failed_attempt(data['email'], request.remote_addr)</p>
<p>                        return jsonify({</p>
<p>                            'status': 'error',</p>
<p>                            'error': {</p>
<p>                                'code': 'INVALID_CREDENTIALS',</p>
<p>                                'message': 'Invalid email or password'</p>
<p>                            }</p>
<p>                        }), 401</p>
                    
<p>                    # MFAチェック</p>
<p>                    if user.mfa_enabled:</p>
<p>                        mfa_token = generate_mfa_token(user.id)</p>
<p>                        return jsonify({</p>
<p>                            'status': 'success',</p>
<p>                            'data': {</p>
<p>                                'mfa_token': mfa_token,</p>
<p>                                'mfa_methods': get_user_mfa_methods(user.id),</p>
<p>                                'expires_at': get_expiry_time(minutes=5)</p>
<p>                            }</p>
<p>                        })</p>
                    
<p>                    # セッション作成</p>
<p>                    session = create_session(user, request)</p>
                    
<p>                    return jsonify({</p>
<p>                        'status': 'success',</p>
<p>                        'data': {</p>
<p>                            'user': serialize_user(user),</p>
<p>                            'session': {</p>
<p>                                'token': session.token,</p>
<p>                                'expires_at': session.expires_at</p>
<p>                            }</p>
<p>                        }</p>
<p>                    })</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'logout': {</p>
<p>                'endpoint': 'POST /api/v1/auth/logout',</p>
<p>                'description': 'ユーザーログアウト',</p>
<p>                'request': {</p>
<p>                    'headers': {</p>
<p>                        'Authorization': 'Bearer {session_token}'</p>
<p>                    },</p>
<p>                    'body': {</p>
<p>                        'everywhere': False  # 全デバイスからログアウト</p>
<p>                    }</p>
<p>                },</p>
<p>                'response': {</p>
<p>                    'success': {</p>
<p>                        'status': 'success',</p>
<p>                        'data': {</p>
<p>                            'message': 'Successfully logged out'</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            },</p>
            
<p>            'refresh': {</p>
<p>                'endpoint': 'POST /api/v1/auth/refresh',</p>
<p>                'description': 'セッションリフレッシュ',</p>
<p>                'request': {</p>
<p>                    'headers': {</p>
<p>                        'Authorization': 'Bearer {refresh_token}'</p>
<p>                    }</p>
<p>                },</p>
<p>                'response': {</p>
<p>                    'success': {</p>
<p>                        'status': 'success',</p>
<p>                        'data': {</p>
<p>                            'session': {</p>
<p>                                'token': 'new_session_token',</p>
<p>                                'expires_at': '2024-01-15T19:30:00Z'</p>
<p>                            }</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def user_management_endpoints(self):</p>
<p>        """ユーザー管理エンドポイント"""</p>
        
<p>        return {</p>
<p>            'register': {</p>
<p>                'endpoint': 'POST /api/v1/auth/register',</p>
<p>                'description': '新規ユーザー登録',</p>
<p>                'request': {</p>
<p>                    'body': {</p>
<p>                        'email': 'user@example.com',</p>
<p>                        'password': 'secure_password',</p>
<p>                        'name': 'John Doe',</p>
<p>                        'accept_terms': True</p>
<p>                    }</p>
<p>                },</p>
<p>                'validation': '''</p>
<p>                def validate_registration(data):</p>
<p>                    errors = {}</p>
                    
<p>                    # Email検証</p>
<p>                    if not is_valid_email(data.get('email')):</p>
<p>                        errors['email'] = 'Invalid email format'</p>
<p>                    elif email_exists(data.get('email')):</p>
<p>                        errors['email'] = 'Email already registered'</p>
                    
<p>                    # パスワード検証</p>
<p>                    password_errors = validate_password(data.get('password'))</p>
<p>                    if password_errors:</p>
<p>                        errors['password'] = password_errors</p>
                    
<p>                    # 利用規約</p>
<p>                    if not data.get('accept_terms'):</p>
<p>                        errors['accept_terms'] = 'You must accept the terms'</p>
                    
<p>                    return errors</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'profile': {</p>
<p>                'get': {</p>
<p>                    'endpoint': 'GET /api/v1/users/me',</p>
<p>                    'description': '現在のユーザー情報取得',</p>
<p>                    'response': {</p>
<p>                        'id': 'uuid',</p>
<p>                        'email': 'user@example.com',</p>
<p>                        'name': 'John Doe',</p>
<p>                        'created_at': '2024-01-01T00:00:00Z',</p>
<p>                        'mfa_enabled': False</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'update': {</p>
<p>                    'endpoint': 'PATCH /api/v1/users/me',</p>
<p>                    'description': 'プロフィール更新',</p>
<p>                    'request': {</p>
<p>                        'body': {</p>
<p>                            'name': 'Jane Doe',</p>
<p>                            'timezone': 'Asia/Tokyo'</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            },</p>
            
<p>            'password_reset': {</p>
<p>                'request': {</p>
<p>                    'endpoint': 'POST /api/v1/auth/password-reset',</p>
<p>                    'description': 'パスワードリセット要求',</p>
<p>                    'request': {</p>
<p>                        'body': {</p>
<p>                            'email': 'user@example.com'</p>
<p>                        }</p>
<p>                    },</p>
<p>                    'implementation': '''</p>
<p>                    @app.route('/api/v1/auth/password-reset', methods=['POST'])</p>
<p>                    @rate_limit(calls=3, period=3600)  # 3 requests per hour</p>
<p>                    def request_password_reset():</p>
<p>                        email = request.json.get('email')</p>
                        
<p>                        # 常に同じレスポンスを返す（情報漏洩防止）</p>
<p>                        response = {</p>
<p>                            'status': 'success',</p>
<p>                            'data': {</p>
<p>                                'message': 'If the email exists, a reset link has been sent'</p>
<p>                            }</p>
<p>                        }</p>
                        
<p>                        # 非同期でメール送信</p>
<p>                        if is_valid_email(email):</p>
<p>                            user = get_user_by_email(email)</p>
<p>                            if user:</p>
<p>                                token = generate_reset_token(user.id)</p>
<p>                                send_reset_email.delay(user.email, token)</p>
                        
<p>                        return jsonify(response)</p>
<p>                    '''</p>
<p>                },</p>
                
<p>                'confirm': {</p>
<p>                    'endpoint': 'POST /api/v1/auth/password-reset/confirm',</p>
<p>                    'description': 'パスワードリセット実行',</p>
<p>                    'request': {</p>
<p>                        'body': {</p>
<p>                            'token': 'reset_token',</p>
<p>                            'password': 'new_secure_password'</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def security_endpoints(self):</p>
<p>        """セキュリティ関連エンドポイント"""</p>
        
<p>        return {</p>
<p>            'mfa_endpoints': {</p>
<p>                'setup': {</p>
<p>                    'endpoint': 'POST /api/v1/users/me/mfa/setup',</p>
<p>                    'description': 'MFA設定開始',</p>
<p>                    'request': {</p>
<p>                        'body': {</p>
<p>                            'method': 'totp'</p>
<p>                        }</p>
<p>                    },</p>
<p>                    'response': {</p>
<p>                        'status': 'success',</p>
<p>                        'data': {</p>
<p>                            'secret': 'base32_secret',</p>
<p>                            'qr_code': 'data:image/png;base64,...',</p>
<p>                            'backup_codes': [</p>
<p>                                'XXXX-XXXX',</p>
<p>                                'YYYY-YYYY'</p>
<p>                            ]</p>
<p>                        }</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'verify': {</p>
<p>                    'endpoint': 'POST /api/v1/auth/mfa/verify',</p>
<p>                    'description': 'MFA検証',</p>
<p>                    'request': {</p>
<p>                        'headers': {</p>
<p>                            'X-MFA-Token': 'temporary_token'</p>
<p>                        },</p>
<p>                        'body': {</p>
<p>                            'code': '123456'</p>
<p>                        }</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'disable': {</p>
<p>                    'endpoint': 'DELETE /api/v1/users/me/mfa',</p>
<p>                    'description': 'MFA無効化',</p>
<p>                    'request': {</p>
<p>                        'body': {</p>
<p>                            'password': 'current_password'</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            },</p>
            
<p>            'sessions_management': {</p>
<p>                'list': {</p>
<p>                    'endpoint': 'GET /api/v1/users/me/sessions',</p>
<p>                    'description': 'アクティブセッション一覧',</p>
<p>                    'response': {</p>
<p>                        'sessions': [{</p>
<p>                            'id': 'session_id',</p>
<p>                            'device': 'Chrome on Windows',</p>
<p>                            'ip_address': '192.168.1.1',</p>
<p>                            'location': 'Tokyo, Japan',</p>
<p>                            'created_at': '2024-01-15T10:00:00Z',</p>
<p>                            'last_activity': '2024-01-15T10:30:00Z',</p>
<p>                            'is_current': True</p>
<p>                        }]</p>
<p>                    }</p>
<p>                },</p>
                
<p>                'revoke': {</p>
<p>                    'endpoint': 'DELETE /api/v1/users/me/sessions/{session_id}',</p>
<p>                    'description': '特定セッションの無効化'</p>
<p>                },</p>
                
<p>                'revoke_all': {</p>
<p>                    'endpoint': 'DELETE /api/v1/users/me/sessions',</p>
<p>                    'description': '全セッションの無効化',</p>
<p>                    'request': {</p>
<p>                        'body': {</p>
<p>                            'except_current': True</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h3>8.3.2 API セキュリティ実装</h3><p><pre><code>python</p>
<p>class APISecurityImplementation:</p>
<p>    """APIセキュリティ実装"""</p>
    
<p>    def authentication_middleware(self):</p>
<p>        """認証ミドルウェア"""</p>
        
<p>        return {</p>
<p>            'bearer_token_auth': '''</p>
<p>            from functools import wraps</p>
<p>            from flask import request, jsonify, g</p>
            
<p>            def require_auth(f):</p>
<p>                @wraps(f)</p>
<p>                def decorated_function(<em>args, </em>*kwargs):</p>
<p>                    # Authorization ヘッダーの確認</p>
<p>                    auth_header = request.headers.get('Authorization')</p>
<p>                    if not auth_header:</p>
<p>                        return jsonify({</p>
<p>                            'status': 'error',</p>
<p>                            'error': {</p>
<p>                                'code': 'MISSING_AUTH',</p>
<p>                                'message': 'Authorization header required'</p>
<p>                            }</p>
<p>                        }), 401</p>
                    
<p>                    # Bearer トークンの抽出</p>
<p>                    try:</p>
<p>                        scheme, token = auth_header.split(' ')</p>
<p>                        if scheme.lower() != 'bearer':</p>
<p>                            raise ValueError('Invalid scheme')</p>
<p>                    except ValueError:</p>
<p>                        return jsonify({</p>
<p>                            'status': 'error',</p>
<p>                            'error': {</p>
<p>                                'code': 'INVALID_AUTH_FORMAT',</p>
<p>                                'message': 'Authorization header must be Bearer token'</p>
<p>                            }</p>
<p>                        }), 401</p>
                    
<p>                    # セッション検証</p>
<p>                    session = validate_session(token)</p>
<p>                    if not session:</p>
<p>                        return jsonify({</p>
<p>                            'status': 'error',</p>
<p>                            'error': {</p>
<p>                                'code': 'INVALID_TOKEN',</p>
<p>                                'message': 'Invalid or expired token'</p>
<p>                            }</p>
<p>                        }), 401</p>
                    
<p>                    # ユーザー情報をコンテキストに追加</p>
<p>                    g.current_user = session.user</p>
<p>                    g.current_session = session</p>
                    
<p>                    return f(<em>args, </em>*kwargs)</p>
                
<p>                return decorated_function</p>
<p>            ''',</p>
            
<p>            'rate_limiting': '''</p>
<p>            from flask_limiter import Limiter</p>
<p>            from flask_limiter.util import get_remote_address</p>
            
<p>            limiter = Limiter(</p>
<p>                app,</p>
<p>                key_func=get_remote_address,</p>
<p>                default_limits=["1000 per hour"],</p>
<p>                storage_uri="redis://localhost:6379"</p>
<p>            )</p>
            
<p>            # エンドポイント別のレート制限</p>
<p>            @app.route('/api/v1/auth/login', methods=['POST'])</p>
<p>            @limiter.limit("5 per 5 minutes")</p>
<p>            def login():</p>
<p>                pass</p>
            
<p>            @app.route('/api/v1/auth/register', methods=['POST'])</p>
<p>            @limiter.limit("3 per hour")</p>
<p>            def register():</p>
<p>                pass</p>
            
<p>            # 動的レート制限</p>
<p>            def get_rate_limit():</p>
<p>                if g.current_user and g.current_user.is_premium:</p>
<p>                    return "10000 per hour"</p>
<p>                return "1000 per hour"</p>
            
<p>            @app.route('/api/v1/data')</p>
<p>            @limiter.limit(get_rate_limit)</p>
<p>            def get_data():</p>
<p>                pass</p>
<p>            ''',</p>
            
<p>            'input_validation': '''</p>
<p>            from marshmallow import Schema, fields, validate, ValidationError</p>
            
<p>            class LoginSchema(Schema):</p>
<p>                email = fields.Email(required=True)</p>
<p>                password = fields.Str(</p>
<p>                    required=True,</p>
<p>                    validate=validate.Length(min=8, max=128)</p>
<p>                )</p>
<p>                remember_me = fields.Bool(missing=False)</p>
<p>                device_fingerprint = fields.Str(</p>
<p>                    validate=validate.Length(equal=64)</p>
<p>                )</p>
            
<p>            def validate_input(schema_class):</p>
<p>                def decorator(f):</p>
<p>                    @wraps(f)</p>
<p>                    def decorated_function(<em>args, </em>*kwargs):</p>
<p>                        schema = schema_class()</p>
<p>                        try:</p>
<p>                            data = schema.load(request.get_json())</p>
<p>                            request.validated_data = data</p>
<p>                        except ValidationError as err:</p>
<p>                            return jsonify({</p>
<p>                                'status': 'error',</p>
<p>                                'error': {</p>
<p>                                    'code': 'VALIDATION_ERROR',</p>
<p>                                    'details': err.messages</p>
<p>                                }</p>
<p>                            }), 400</p>
                        
<p>                        return f(<em>args, </em>*kwargs)</p>
                    
<p>                    return decorated_function</p>
<p>                return decorator</p>
            
<p>            @app.route('/api/v1/auth/login', methods=['POST'])</p>
<p>            @validate_input(LoginSchema)</p>
<p>            def login():</p>
<p>                data = request.validated_data</p>
<p>                # 検証済みデータを使用</p>
<p>            '''</p>
<p>        }</p>
    
<p>    def security_headers(self):</p>
<p>        """セキュリティヘッダー"""</p>
        
<p>        return {</p>
<p>            'implementation': '''</p>
<p>            @app.after_request</p>
<p>            def set_security_headers(response):</p>
<p>                # 基本的なセキュリティヘッダー</p>
<p>                response.headers['X-Content-Type-Options'] = 'nosniff'</p>
<p>                response.headers['X-Frame-Options'] = 'DENY'</p>
<p>                response.headers['X-XSS-Protection'] = '1; mode=block'</p>
<p>                response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'</p>
                
<p>                # Content Security Policy</p>
<p>                response.headers['Content-Security-Policy'] = "; ".join([</p>
<p>                    "default-src 'self'",</p>
<p>                    "script-src 'self' 'unsafe-inline'",</p>
<p>                    "style-src 'self' 'unsafe-inline'",</p>
<p>                    "img-src 'self' data: https:",</p>
<p>                    "font-src 'self'",</p>
<p>                    "connect-src 'self'",</p>
<p>                    "frame-ancestors 'none'"</p>
<p>                ])</p>
                
<p>                # CORS設定（必要に応じて）</p>
<p>                if request.origin in app.config['ALLOWED_ORIGINS']:</p>
<p>                    response.headers['Access-Control-Allow-Origin'] = request.origin</p>
<p>                    response.headers['Access-Control-Allow-Credentials'] = 'true'</p>
                
<p>                return response</p>
<p>            ''',</p>
            
<p>            'api_versioning': '''</p>
<p>            # URLパスでのバージョニング</p>
<p>            @app.route('/api/v1/users/<user_id>')</p>
<p>            def get_user_v1(user_id):</p>
<p>                # v1 実装</p>
<p>                pass</p>
            
<p>            @app.route('/api/v2/users/<user_id>')</p>
<p>            def get_user_v2(user_id):</p>
<p>                # v2 実装（拡張フィールド付き）</p>
<p>                pass</p>
            
<p>            # ヘッダーでのバージョニング</p>
<p>            @app.route('/api/users/<user_id>')</p>
<p>            def get_user(user_id):</p>
<p>                api_version = request.headers.get('API-Version', 'v1')</p>
                
<p>                if api_version == 'v2':</p>
<p>                    return get_user_v2_logic(user_id)</p>
<p>                else:</p>
<p>                    return get_user_v1_logic(user_id)</p>
<p>            '''</p>
<p>        }</p>
<p></code></pre></p><h2>8.4 エラーハンドリングとユーザビリティ</h2><h3>8.4.1 エラー設計の原則</h3><p><pre><code>python</p>
<p>class ErrorHandlingDesign:</p>
<p>    """エラーハンドリング設計"""</p>
    
<p>    def error_design_principles(self):</p>
<p>        """エラー設計の原則"""</p>
        
<p>        return {</p>
<p>            'user_friendly_errors': {</p>
<p>                'principle': 'ユーザーが理解し、行動できるエラーメッセージ',</p>
<p>                'bad_example': {</p>
<p>                    'message': 'Error 0x80070005',</p>
<p>                    'problem': '意味不明、対処法が不明'</p>
<p>                },</p>
<p>                'good_example': {</p>
<p>                    'message': 'パスワードが間違っています。大文字小文字を確認してください。',</p>
<p>                    'reason': '具体的で行動可能'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'security_conscious_errors': {</p>
<p>                'principle': 'セキュリティ情報を漏らさない',</p>
<p>                'bad_example': {</p>
<p>                    'message': 'ユーザー user@example.com は存在しません',</p>
<p>                    'problem': 'アカウントの存在確認に使える'</p>
<p>                },</p>
<p>                'good_example': {</p>
<p>                    'message': 'メールアドレスまたはパスワードが正しくありません',</p>
<p>                    'reason': '情報を特定できない'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'actionable_errors': {</p>
<p>                'principle': 'ユーザーが次に何をすべきか明確',</p>
<p>                'example': {</p>
<p>                    'error': 'アカウントがロックされています',</p>
<p>                    'action': '5分後に再度お試しください',</p>
<p>                    'help_link': '/support/account-locked'</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def error_taxonomy(self):</p>
<p>        """エラーの分類"""</p>
        
<p>        return {</p>
<p>            'client_errors': {</p>
<p>                'validation_errors': {</p>
<p>                    'code': 'VALIDATION_ERROR',</p>
<p>                    'http_status': 400,</p>
<p>                    'examples': [</p>
<p>                        'メールアドレスの形式が正しくありません',</p>
<p>                        'パスワードは8文字以上必要です',</p>
<p>                        '利用規約への同意が必要です'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'authentication_errors': {</p>
<p>                    'code': 'AUTH_ERROR',</p>
<p>                    'http_status': 401,</p>
<p>                    'examples': [</p>
<p>                        'ログインが必要です',</p>
<p>                        'セッションの有効期限が切れました',</p>
<p>                        '認証情報が正しくありません'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'authorization_errors': {</p>
<p>                    'code': 'FORBIDDEN',</p>
<p>                    'http_status': 403,</p>
<p>                    'examples': [</p>
<p>                        'この操作を行う権限がありません',</p>
<p>                        'アカウントが一時的に制限されています'</p>
<p>                    ]</p>
<p>                },</p>
                
<p>                'rate_limit_errors': {</p>
<p>                    'code': 'RATE_LIMITED',</p>
<p>                    'http_status': 429,</p>
<p>                    'examples': [</p>
<p>                        'リクエストが多すぎます。しばらくお待ちください',</p>
<p>                        '1時間に5回までしか試行できません'</p>
<p>                    ]</p>
<p>                }</p>
<p>            },</p>
            
<p>            'server_errors': {</p>
<p>                'internal_errors': {</p>
<p>                    'code': 'INTERNAL_ERROR',</p>
<p>                    'http_status': 500,</p>
<p>                    'user_message': 'システムエラーが発生しました。しばらく経ってから再度お試しください。',</p>
<p>                    'log_detail': True</p>
<p>                },</p>
                
<p>                'service_unavailable': {</p>
<p>                    'code': 'SERVICE_UNAVAILABLE',</p>
<p>                    'http_status': 503,</p>
<p>                    'user_message': 'メンテナンス中です。10分後に再度アクセスしてください。'</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
    
<p>    def error_response_format(self):</p>
<p>        """エラーレスポンス形式"""</p>
        
<p>        return {</p>
<p>            'standard_format': {</p>
<p>                'status': 'error',</p>
<p>                'error': {</p>
<p>                    'code': 'ERROR_CODE',</p>
<p>                    'message': 'ユーザー向けメッセージ',</p>
<p>                    'field': 'エラーが発生したフィールド（任意）',</p>
<p>                    'details': '追加情報（任意）',</p>
<p>                    'request_id': 'リクエストID（サポート用）'</p>
<p>                }</p>
<p>            },</p>
            
<p>            'validation_error_format': {</p>
<p>                'status': 'error',</p>
<p>                'error': {</p>
<p>                    'code': 'VALIDATION_ERROR',</p>
<p>                    'message': '入力内容に誤りがあります',</p>
<p>                    'details': {</p>
<p>                        'email': ['メールアドレスの形式が正しくありません'],</p>
<p>                        'password': [</p>
<p>                            'パスワードは8文字以上必要です',</p>
<p>                            '少なくとも1つの数字を含めてください'</p>
<p>                        ]</p>
<p>                    }</p>
<p>                }</p>
<p>            },</p>
            
<p>            'implementation': '''</p>
<p>            class APIError(Exception):</p>
<p>                """API エラーの基底クラス"""</p>
                
<p>                def __init__(self, code, message, status_code=400, details=None):</p>
<p>                    self.code = code</p>
<p>                    self.message = message</p>
<p>                    self.status_code = status_code</p>
<p>                    self.details = details</p>
<p>                    super().__init__(self.message)</p>
                
<p>                def to_dict(self):</p>
<p>                    response = {</p>
<p>                        'status': 'error',</p>
<p>                        'error': {</p>
<p>                            'code': self.code,</p>
<p>                            'message': self.message,</p>
<p>                            'request_id': g.request_id</p>
<p>                        }</p>
<p>                    }</p>
                    
<p>                    if self.details:</p>
<p>                        response['error']['details'] = self.details</p>
                    
<p>                    return response</p>
            
<p>            class ValidationError(APIError):</p>
<p>                def __init__(self, errors):</p>
<p>                    super().__init__(</p>
<p>                        code='VALIDATION_ERROR',</p>
<p>                        message='入力内容に誤りがあります',</p>
<p>                        status_code=400,</p>
<p>                        details=errors</p>
<p>                    )</p>
            
<p>            class AuthenticationError(APIError):</p>
<p>                def __init__(self, message='認証が必要です'):</p>
<p>                    super().__init__(</p>
<p>                        code='AUTHENTICATION_REQUIRED',</p>
<p>                        message=message,</p>
<p>                        status_code=401</p>
<p>                    )</p>
            
<p>            @app.errorhandler(APIError)</p>
<p>            def handle_api_error(error):</p>
<p>                response = jsonify(error.to_dict())</p>
<p>                response.status_code = error.status_code</p>
                
<p>                # エラーログ</p>
<p>                if error.status_code >= 500:</p>
<p>                    app.logger.error(</p>
<p>                        f"API Error: {error.code}",</p>
<p>                        extra={</p>
<p>                            'request_id': g.request_id,</p>
<p>                            'user_id': g.get('current_user', {}).get('id'),</p>
<p>                            'error_details': error.details</p>
<p>                        }</p>
<p>                    )</p>
                
<p>                return response</p>
<p>            '''</p>
<p>        }</p>
<p></code></pre></p><h3>8.4.2 ユーザビリティの向上</h3><p><pre><code>python</p>
<p>class UsabilityEnhancements:</p>
<p>    """ユーザビリティの向上"""</p>
    
<p>    def user_experience_patterns(self):</p>
<p>        """UXパターン"""</p>
        
<p>        return {</p>
<p>            'progressive_disclosure': {</p>
<p>                'concept': '段階的な情報開示',</p>
<p>                'login_flow': {</p>
<p>                    'step1': {</p>
<p>                        'show': ['email'],</p>
<p>                        'hide': ['password', 'mfa']</p>
<p>                    },</p>
<p>                    'step2': {</p>
<p>                        'show': ['password'],</p>
<p>                        'context': 'ユーザー名確認後'</p>
<p>                    },</p>
<p>                    'step3': {</p>
<p>                        'show': ['mfa'],</p>
<p>                        'context': 'MFA有効時のみ'</p>
<p>                    }</p>
<p>                },</p>
<p>                'benefits': [</p>
<p>                    '認知負荷の軽減',</p>
<p>                    'エラーの段階的な処理',</p>
<p>                    'よりスムーズな体験'</p>
<p>                ]</p>
<p>            },</p>
            
<p>            'helpful_feedback': {</p>
<p>                'password_strength': '''</p>
<p>                function checkPasswordStrength(password) {</p>
<p>                    const feedback = {</p>
<p>                        score: 0,</p>
<p>                        suggestions: []</p>
<p>                    };</p>
                    
<p>                    // 長さチェック</p>
<p>                    if (password.length < 8) {</p>
<p>                        feedback.suggestions.push('8文字以上にしてください');</p>
<p>                    } else if (password.length < 12) {</p>
<p>                        feedback.score += 1;</p>
<p>                        feedback.suggestions.push('12文字以上だとより安全です');</p>
<p>                    } else {</p>
<p>                        feedback.score += 2;</p>
<p>                    }</p>
                    
<p>                    // 文字種チェック</p>
<p>                    const patterns = {</p>
<p>                        lowercase: /[a-z]/,</p>
<p>                        uppercase: /[A-Z]/,</p>
<p>                        numbers: /[0-9]/,</p>
<p>                        special: /[^A-Za-z0-9]/</p>
<p>                    };</p>
                    
<p>                    let types = 0;</p>
<p>                    for (const [type, pattern] of Object.entries(patterns)) {</p>
<p>                        if (pattern.test(password)) {</p>
<p>                            types++;</p>
<p>                        }</p>
<p>                    }</p>
                    
<p>                    feedback.score += types;</p>
                    
<p>                    // 強度表示</p>
<p>                    if (feedback.score <= 2) {</p>
<p>                        feedback.strength = 'weak';</p>
<p>                        feedback.color = '#dc3545';</p>
<p>                        feedback.text = '弱い';</p>
<p>                    } else if (feedback.score <= 4) {</p>
<p>                        feedback.strength = 'medium';</p>
<p>                        feedback.color = '#ffc107';</p>
<p>                        feedback.text = '普通';</p>
<p>                    } else {</p>
<p>                        feedback.strength = 'strong';</p>
<p>                        feedback.color = '#28a745';</p>
<p>                        feedback.text = '強い';</p>
<p>                    }</p>
                    
<p>                    return feedback;</p>
<p>                }</p>
<p>                ''',</p>
                
<p>                'real_time_validation': '''</p>
<p>                // リアルタイム検証</p>
<p>                const emailInput = document.getElementById('email');</p>
<p>                let validationTimer;</p>
                
<p>                emailInput.addEventListener('input', (e) => {</p>
<p>                    clearTimeout(validationTimer);</p>
                    
<p>                    // デバウンス</p>
<p>                    validationTimer = setTimeout(() => {</p>
<p>                        validateEmail(e.target.value);</p>
<p>                    }, 500);</p>
<p>                });</p>
                
<p>                async function validateEmail(email) {</p>
<p>                    // 基本的な形式チェック</p>
<p>                    if (!isValidEmailFormat(email)) {</p>
<p>                        showError('email', 'メールアドレスの形式が正しくありません');</p>
<p>                        return;</p>
<p>                    }</p>
                    
<p>                    // 既存チェック（オプション）</p>
<p>                    if (checkingEnabled) {</p>
<p>                        const response = await fetch('/api/v1/auth/check-email', {</p>
<p>                            method: 'POST',</p>
<p>                            body: JSON.stringify({ email })</p>
<p>                        });</p>
                        
<p>                        if (response.ok) {</p>
<p>                            showSuccess('email', '利用可能です');</p>
<p>                        }</p>
<p>                    }</p>
<p>                }</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'accessibility': {</p>
<p>                'aria_labels': '''</p>
<p>                <form role="form" aria-label="ログインフォーム"></p>
<p>                    <div class="form-group"></p>
<p>                        <label for="email">メールアドレス</label></p>
<p>                        <input</p>
<p>                            type="email"</p>
<p>                            id="email"</p>
<p>                            name="email"</p>
<p>                            required</p>
<p>                            aria-required="true"</p>
<p>                            aria-describedby="email-error"</p>
<p>                            aria-invalid="false"</p>
<p>                        /></p>
<p>                        <span id="email-error" class="error" role="alert"></span></p>
<p>                    </div></p>
                    
<p>                    <button type="submit" aria-busy="false"></p>
<p>                        ログイン</p>
<p>                    </button></p>
<p>                </form></p>
<p>                ''',</p>
                
<p>                'keyboard_navigation': '''</p>
<p>                // キーボードナビゲーション</p>
<p>                document.addEventListener('keydown', (e) => {</p>
<p>                    if (e.key === 'Enter') {</p>
<p>                        const activeElement = document.activeElement;</p>
                        
<p>                        if (activeElement.tagName === 'INPUT') {</p>
<p>                            const form = activeElement.closest('form');</p>
<p>                            const inputs = form.querySelectorAll('input');</p>
<p>                            const index = Array.from(inputs).indexOf(activeElement);</p>
                            
<p>                            if (index < inputs.length - 1) {</p>
<p>                                // 次の入力フィールドへ</p>
<p>                                inputs[index + 1].focus();</p>
<p>                                e.preventDefault();</p>
<p>                            } else {</p>
<p>                                // 送信</p>
<p>                                form.submit();</p>
<p>                            }</p>
<p>                        }</p>
<p>                    }</p>
<p>                });</p>
<p>                '''</p>
<p>            }</p>
<p>        }</p>
    
<p>    def performance_optimization(self):</p>
<p>        """パフォーマンス最適化"""</p>
        
<p>        return {</p>
<p>            'api_performance': {</p>
<p>                'caching_strategy': '''</p>
<p>                from functools import lru_cache</p>
<p>                import redis</p>
                
<p>                redis_client = redis.Redis()</p>
                
<p>                @lru_cache(maxsize=1000)</p>
<p>                def get_user_permissions(user_id):</p>
<p>                    """ユーザー権限のキャッシュ"""</p>
<p>                    # Redisから取得</p>
<p>                    cache_key = f"permissions:{user_id}"</p>
<p>                    cached = redis_client.get(cache_key)</p>
                    
<p>                    if cached:</p>
<p>                        return json.loads(cached)</p>
                    
<p>                    # DBから取得</p>
<p>                    permissions = fetch_user_permissions_from_db(user_id)</p>
                    
<p>                    # Redisにキャッシュ（5分）</p>
<p>                    redis_client.setex(</p>
<p>                        cache_key,</p>
<p>                        300,</p>
<p>                        json.dumps(permissions)</p>
<p>                    )</p>
                    
<p>                    return permissions</p>
<p>                ''',</p>
                
<p>                'response_compression': '''</p>
<p>                from flask_compress import Compress</p>
                
<p>                app = Flask(__name__)</p>
<p>                Compress(app)</p>
                
<p>                # 特定のレスポンスのみ圧縮</p>
<p>                @app.route('/api/v1/users')</p>
<p>                def get_users():</p>
<p>                    users = fetch_users()</p>
<p>                    response = jsonify(users)</p>
                    
<p>                    # 大きなレスポンスのみ圧縮</p>
<p>                    if len(response.data) > 1024:  # 1KB以上</p>
<p>                        response.headers['Content-Encoding'] = 'gzip'</p>
                    
<p>                    return response</p>
<p>                ''',</p>
                
<p>                'pagination': '''</p>
<p>                def paginate_query(query, page=1, per_page=20, max_per_page=100):</p>
<p>                    """効率的なページネーション"""</p>
                    
<p>                    # per_pageの制限</p>
<p>                    per_page = min(per_page, max_per_page)</p>
                    
<p>                    # カーソルベースのページネーション（大規模データ用）</p>
<p>                    if page > 100:  # 深いページの場合</p>
<p>                        return cursor_paginate(query, cursor, per_page)</p>
                    
<p>                    # オフセットベース（通常のケース）</p>
<p>                    paginated = query.paginate(</p>
<p>                        page=page,</p>
<p>                        per_page=per_page,</p>
<p>                        error_out=False</p>
<p>                    )</p>
                    
<p>                    return {</p>
<p>                        'items': [item.to_dict() for item in paginated.items],</p>
<p>                        'pagination': {</p>
<p>                            'page': page,</p>
<p>                            'per_page': per_page,</p>
<p>                            'total': paginated.total,</p>
<p>                            'pages': paginated.pages,</p>
<p>                            'has_next': paginated.has_next,</p>
<p>                            'has_prev': paginated.has_prev</p>
<p>                        }</p>
<p>                    }</p>
<p>                '''</p>
<p>            },</p>
            
<p>            'frontend_optimization': {</p>
<p>                'lazy_loading': '''</p>
<p>                // 遅延読み込み</p>
<p>                const loadMFASettings = () => {</p>
<p>                    import('./mfa-settings.js').then(module => {</p>
<p>                        module.initializeMFA();</p>
<p>                    });</p>
<p>                };</p>
                
<p>                // IntersectionObserverで可視時に読み込み</p>
<p>                const observer = new IntersectionObserver((entries) => {</p>
<p>                    entries.forEach(entry => {</p>
<p>                        if (entry.isIntersecting) {</p>
<p>                            loadMFASettings();</p>
<p>                            observer.unobserve(entry.target);</p>
<p>                        }</p>
<p>                    });</p>
<p>                });</p>
                
<p>                observer.observe(document.getElementById('mfa-section'));</p>
<p>                ''',</p>
                
<p>                'optimistic_updates': '''</p>
<p>                // 楽観的更新</p>
<p>                async function updateProfile(data) {</p>
<p>                    // UIを即座に更新</p>
<p>                    updateUIOptimistically(data);</p>
                    
<p>                    try {</p>
<p>                        const response = await api.updateProfile(data);</p>
<p>                        // 成功</p>
<p>                        showSuccess('プロフィールを更新しました');</p>
<p>                    } catch (error) {</p>
<p>                        // 失敗時は元に戻す</p>
<p>                        revertUIUpdate();</p>
<p>                        showError('更新に失敗しました');</p>
<p>                    }</p>
<p>                }</p>
<p>                '''</p>
<p>            }</p>
<p>        }</p>
<p></code></pre></p><h2>まとめ</h2><p>この章では、実践的な認証システムの設計について学びました：</p><p>1. <strong>要件定義と設計の進め方</strong></p>
<p>   - ビジネス要件から技術要件への落とし込み</p>
<p>   - セキュリティ要件の明確化</p>
<p>   - 段階的な実装アプローチ</p><p>2. <strong>データベース設計</strong></p>
<p>   - 認証システムに必要なエンティティ</p>
<p>   - パフォーマンスを考慮したインデックス戦略</p>
<p>   - スケーラビリティのための設計パターン</p><p>3. <strong>API設計とエンドポイント</strong></p>
<p>   - RESTfulな認証API設計</p>
<p>   - セキュリティを考慮した実装</p>
<p>   - エラーハンドリングのベストプラクティス</p><p>4. <strong>エラーハンドリングとユーザビリティ</strong></p>
<p>   - ユーザーフレンドリーなエラー設計</p>
<p>   - アクセシビリティの考慮</p>
<p>   - パフォーマンス最適化</p><p>次章では、マイクロサービス環境での認証認可について学びます。</p><h2>演習問題</h2><h3>問題1：要件定義</h3>
<p>スタートアップのSaaSプロダクト（B2B、想定ユーザー1万社）の認証システムの要件定義を作成しなさい。ビジネス要件、セキュリティ要件、技術要件を含めること。</p><h3>問題2：データベース設計</h3>
<p>以下の要件を満たすデータベーススキーマを設計しなさい：</p>
<p>- マルチテナント対応</p>
<p>- 監査ログの長期保存</p>
<p>- GDPR準拠（データ削除要求対応）</p>
<p>- 月間10億リクエスト対応</p><h3>問題3：API設計</h3>
<p>企業向けSSOをサポートする認証APIを設計しなさい。SAML、OIDC、独自認証の3つをサポートし、統一されたAPIインターフェースを提供すること。</p><h3>問題4：エラー設計</h3>
<p>多言語対応（日英中）の認証システムのエラーメッセージ体系を設計しなさい。セキュリティとユーザビリティのバランスを考慮すること。</p><h3>問題5：パフォーマンス設計</h3>
<p>秒間1万リクエストを処理できる認証システムのアーキテクチャを設計しなさい。コスト効率も考慮し、段階的なスケーリング計画を含めること。</p>
            </div>
        </main>
    </div>
</body>
</html>